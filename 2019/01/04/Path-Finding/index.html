<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Path Finding | luka712 blog</title><meta name="description" content="Find out how to implement A* path finding. And maybe add some navigation to your games or ... "><meta name="generator" content="luka712 blog"><meta name="author" content="Luka Erkapic"><meta name="keywords" content="sjaak van den berg, svdb, bitcoin, crypto, payment, integration, bitcoins, wordpress, betaling, webshop, front end, design, ontwerp, developer"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="stylesheet" type="text/css" href="/styles/style.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="160x160" href="/images/favicon-160x160.png"><link rel="icon" type="image/png" sizes="192x192" href="/images/favicon-192x192.png"><meta name="msapplication-TileColor" content="#121315"><meta name="msapplication-TileImage" content="/images/mstile-144x144.png"></head><body itemscope itemtype="https://schema.org/WebPage" onload="onLoad()"><header itemscope itemtype="https://schema.org/WPHeader"><h1><a href="/" alt="luka712 blog" title="luka712 blog" itemprop="headline" class="header">luka712 blog</a></h1><p itemprop="description"></p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/" alt="Home" title="Home" itemprop="url" class="header">Home</a></li><li itemprop="name"><a href="/About" alt="About" title="About" itemprop="url" class="header">About</a></li></ul></nav><div id="render-space"><canvas id="render-canvas"></canvas></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline">Path Finding</h1><span class="post-meta">Published on<time itemprop="datePublished" datetime="2019-01-04T08:49:20.000Z"> Friday, January 4th 2019 at 9:49</time><br>Last updated on<time itemprop="dateModified" datetime="2019-01-04T08:49:20.000Z"> Friday, January 25th 2019 at 22:28</time></span><h5 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h5><p>You can already assume what path finding is, simply it’s a way of finding shortest route between two points.</p>
<p>This post is going to focus in implementation of <a href="https://en.wikipedia.org/wiki/A*_search_algorithm" target="_blank" rel="noopener">A* (star)</a> search algorithm. There are other algorithms of course, but A* is quite a popular one.</p>
<p>Example below shows algorithm in action, try moving and clicking mouse on example to see how new path is selected. </p>

    <button id="path-finding-reset">Reset</button>
    <br>
    <br>
    <canvas id="path-finding-canvas" width="800" height="600"></canvas>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.11/lodash.min.js"></script>
    <script>
"use strict";var _createClass=function(){function i(i,e){for(var n=0;n<e.length;n++){var l=e[n];l.enumerable=l.enumerable||!1,l.configurable=!0,"value"in l&&(l.writable=!0),Object.defineProperty(i,l.key,l)}}return function(e,n,l){return n&&i(e.prototype,n),l&&i(e,l),e}}();function _classCallCheck(i,e){if(!(i instanceof e))throw new TypeError("Cannot call a class as a function")}var example1Module=function(i){var e=null,n=[],l=void 0,r=void 0,a=[],o=[],t=[],s=void 0,f=void 0,u=!1,c=20,g=30,d=function(){function i(e,n){_classCallCheck(this,i),this.gridX=e,this.gridY=n,this.color="white",this.parent=null,this.f=0,this.g=0,this.h=0,this.isWall=Math.random()>.8}return _createClass(i,[{key:"draw",value:function(i){i.fillStyle=this.color,i.fillRect(this.gridX*s,this.gridY*f,s-1,f-1)}}]),i}(),v=function(){for(var i=0;i<g;i++)for(var e=0;e<c;e++)n[i][e].parent=null;for(u=!0,t=[],o=[l];o.length>0;){var a=_.minBy(o,function(i){return i.f});if(a.gridX===r.gridX&&a.gridY===r.gridY){for(var s=a,f=[s];null!==s.parent;)s=s.parent,f.push(s);return u=!1,f}_.remove(o,a),t.push(a);for(var d=(X=void 0,void 0,void 0,D=void 0,b=void 0,C=void 0,T=void 0,X=[],Y=(w=a).gridX,k=w.gridY,D=!0,b=!0,C=!0,T=!0,w.gridX>0&&!n[Y-1][k].isWall?(X.push(n[Y-1][k]),n[Y-1][k].isDiagonalMove=!1):(D=!1,b=!1),w.gridX<29&&!n[Y+1][k].isWall?(X.push(n[Y+1][k]),n[Y+1][k].isDiagonalMove=!1):(C=!1,T=!1),w.gridY>0&&!n[Y][k-1].isWall?(X.push(n[Y][k-1]),n[Y][k-1].isDiagonalMove=!1):(b=!1,T=!1),w.gridY<19&&!n[Y][k+1].isWall?(X.push(n[Y][k+1]),n[Y][k+1].isDiagonalMove=!1):(D=!1,C=!1),T&&!n[Y+1][k-1].isWall&&(X.push(n[Y+1][k-1]),n[Y+1][k-1].isDiagonalMove=!0),b&&!n[Y-1][k-1].isWall&&(X.push(n[Y-1][k-1]),n[Y-1][k-1].isDiagonalMove=!0),C&&!n[Y+1][k+1].isWall&&(X.push(n[Y+1][k+1]),n[Y+1][k+1].isDiagonalMove=!0),D&&!n[Y-1][k+1].isWall&&(X.push(n[Y-1][k+1]),n[Y-1][k+1].isDiagonalMove=!0),X),v=0;v<d.length;v++){var h=d[v];if(!_.includes(t,h)){h.g=a.g+(h.isDiagonalMove?1.5:1),h.h=(W=r,void 0,void 0,y=(m=h).gridX-W.gridX,M=m.gridY-W.gridY,Math.sqrt(y*y+M*M)),h.f=h.g+h.h;var p=_.indexOf(o,h);if(p<0)o.push(h);else if(h.g>=o[p].g)continue;h.parent=a}}}var m,W,y,M,w,X,Y,k,D,b,C,T;return u=!1,[]},h=function(){var u=e.getContext("2d");s=e.width/g,f=e.height/c,n=[],l=null,r=null;for(var h=0;h<g;h++){n[h]=[];for(var p=0;p<c;p++)n[h][p]=new d(h,p),n[h][p].isWall||l||(l=n[h][p])}for(h=29;h>=0;h--){for(p=19;p>=0&&((r=n[h][p]).isWall&&(r=null),null==r);p--);if(null!=r)break}o=[l],t=[];a=v(),function l(){u.fillStyle="black",u.fillRect(0,0,e.width,e.height);for(var r=0;r<g;r++)for(var o=0;o<c;o++){var t=n[r][o];t.color="white",t.isWall&&(t.color="black"),t.draw(u)}_.forEach(a,function(i){i.color="green",i.draw(u)}),i.requestAnimationFrame(l)}()};return{onload:function(){e=i.document.getElementById("path-finding-canvas"),i.document.getElementById("path-finding-reset").onclick=function(){h()},h()},onclick:function(r){if(!u){var a=i.document.getElementsByTagName("main")[0],o=r.pageX-e.offsetLeft+a.scrollLeft,t=r.pageY-e.offsetTop+a.scrollTop,c=parseInt(o/s),g=parseInt(t/f);n[c]&&n[c][g]&&!n[c][g].isWall&&l!==n[c][g]&&(l=n[c][g])}},onmousemove:function(l){if(!u){var o=i.document.getElementsByTagName("main")[0],t=l.pageX-e.offsetLeft+o.scrollLeft,c=l.pageY-e.offsetTop+o.scrollTop,g=parseInt(t/s),d=parseInt(c/f);n[g]&&n[g][d]&&!n[g][d].isWall&&r!==n[g][d]&&(r=n[g][d],a=v())}}}};
</script>
    

<p>That’s A* path finding. Now before jumping to detailed explanation and implementation of A* search, couple of caveats.<br>You might often find <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" target="_blank" rel="noopener">Dijkstra Algorithm</a> being closely related to it or mentioned next to A*. That because A* search is extension of Djikstra Algorithm.<br>You might also find out, that main difference between the two is, that A* is using heuristic or educated guess to improve upon Dijkstra Algorithm.</p>
<p>Before jumping to all of that, let’s actually review Dijkstra Algorithm. I’m not going to do code for it, although it might be good practice for you, after we finish with code for A*. It’s good to know Dijkstra, since it’s basis for A* and you’re going to see why A* is improvment of it.</p>
<h5 id="Dijkstra-Algorithm"><a href="#Dijkstra-Algorithm" class="headerlink" title="Dijkstra Algorithm"></a>Dijkstra Algorithm</h5><p>First things first, let’s see <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" target="_blank" rel="noopener">Dijkstra Algorithm</a> in action first. Try moving mouse around to see how algorithm is performing search.</p>

 <button id="path-finding-reset-3">Reset</button>
    <br>
    <br>
<canvas id="path-finding-canvas-3" width="800" height="600"></canvas>
<script>"use strict";var _createClass=function(){function l(l,a){for(var r=0;r<a.length;r++){var e=a[r];e.enumerable=e.enumerable||!1,e.configurable=!0,"value"in e&&(e.writable=!0),Object.defineProperty(l,e.key,e)}}return function(a,r,e){return r&&l(a.prototype,r),e&&l(a,e),a}}();function _classCallCheck(l,a){if(!(l instanceof a))throw new TypeError("Cannot call a class as a function")}var example3Module=function(l){var a=null,r=[],e=void 0,n=void 0,i=[],o=[],t=[],s=void 0,f=void 0,u=!1,c=20,g=30,d=1,h=1.5,v=function(){function l(a,r){_classCallCheck(this,l),this.gridX=a,this.gridY=r,this.color="white",this.parent=null,this.f=0,this.g=0,this.h=0,this.isWall=Math.random()>.8}return _createClass(l,[{key:"draw",value:function(l){l.fillStyle=this.color,l.fillRect(this.gridX*s,this.gridY*f,s-1,f-1)}}]),l}(),p=function(l){var a=l.gridX,e=l.gridY;return!!l.isWall||!(l.gridX>0&&!r[a-1][e].isWall)&&(!(l.gridX<g-1&&!r[a+1][e].isWall)&&(!(l.gridY>0&&!r[a][e-1].isWall)&&!(l.gridY<c-1&&!r[a][e+1].isWall)))},m=function(l){var a=[],e=l.gridX,n=l.gridY,i=!0,o=!0,t=!0,s=!0;return l.gridX>0&&!r[e-1][n].isWall?(r[e-1][n].diagonalMove=!1,a.push(r[e-1][n])):(i=!1,o=!1),l.gridX<g-1&&!r[e+1][n].isWall?(r[e+1][n].diagonalMove=!1,a.push(r[e+1][n])):(t=!1,s=!1),l.gridY>0&&!r[e][n-1].isWall?(r[e][n-1].diagonalMove=!1,a.push(r[e][n-1])):(o=!1,s=!1),l.gridY<c-1&&!r[e][n+1].isWall?(r[e][n+1].diagonalMove=!1,a.push(r[e][n+1])):(i=!1,t=!1),s&&!r[e+1][n-1].isWall&&(r[e+1][n-1].diagonalMove=!0,a.push(r[e+1][n-1])),o&&!r[e-1][n-1].isWall&&(r[e-1][n-1].diagonalMove=!0,a.push(r[e-1][n-1])),t&&!r[e+1][n+1].isWall&&(r[e+1][n+1].diagonalMove=!0,a.push(r[e+1][n+1])),i&&!r[e-1][n+1].isWall&&(r[e-1][n+1].diagonalMove=!0,a.push(r[e-1][n+1])),a};function W(){var W=a.getContext("2d");s=a.width/g,f=a.height/c,r=[],o=[],t=[],i=[],u=!1,e=null;for(var w=0;w<g;w++){r[w]=[];for(var y=0;y<c;y++)r[w][y]=new v(w,y),r[w][y].g=1/0,r[w][y].isWall||null!=e||((e=r[w][y]).g=0)}for(w=g-1;w>=0;w--){for(y=c-1;y>=0&&((n=r[w][y]).isWall&&(n=null),null==n);y--);if(null!=n)break}for(w=0;w<g;w++)for(y=0;y<c;y++)p(r[w][y])||o.push(r[w][y]);!function s(){W.fillStyle="black",W.fillRect(0,0,a.width,a.height);for(var f=0;f<g;f++)for(var v=0;v<c;v++){var p=r[f][v];p.color="white",p.isWall&&(p.color="black"),p.draw(W)}if(o.length>0&&!u){var w=_.minBy(o,function(l){return l.g});if(_.remove(o,w),t.push(w),!u){i=[],w==n&&(u=!0);var y=w;for(i.push(y);y.parent;)i.push(y.parent),y=y.parent;y!=e&&(i=[])}for(var M=m(w),X=0;X<M.length;X++){var Y=M[X],k=w.g+(Y.diagonalMove?h:d);k<Y.g&&(Y.g=k,Y.parent=w)}}_.forEach(t,function(l){l.isWall||(l.color="red",l.draw(W))}),_.forEach(i,function(l){l.color="green",l.draw(W)}),l.requestAnimationFrame(s)}()}return{onload:function(){a=l.document.getElementById("path-finding-canvas-3"),l.document.getElementById("path-finding-reset-3").onclick=function(){W()},W()},onclick:function(n){var d=l.document.getElementsByTagName("main")[0],h=n.pageX-a.offsetLeft+d.scrollLeft,v=n.pageY-a.offsetTop+d.scrollTop,m=parseInt(h/s),W=parseInt(v/f);if(r[m]&&r[m][W]&&!r[m][W].isWall&&e!==r[m][W]){i=[],e=r[m][W],u=!1,o=[],t=[];for(var w=0;w<g;w++)for(var y=0;y<c;y++)r[w][y].parent=null,r[w][y].g=1/0,p(r[w][y])||o.push(r[w][y]);e.g=0}},onmousemove:function(d){var h=l.document.getElementsByTagName("main")[0],v=d.pageX-a.offsetLeft+h.scrollLeft,m=d.pageY-a.offsetTop+h.scrollTop,W=parseInt(v/s),w=parseInt(m/f);if(r[W]&&r[W][w]&&!r[W][w].isWall&&n!==r[W][w]){i=[],n=r[W][w],u=!1,o=[],t=[];for(var y=0;y<g;y++)for(var M=0;M<c;M++)r[y][M].parent=null,r[y][M].g=1/0,p(r[y][M])||o.push(r[y][M]);e.g=0}}}};
</script>

<p>From example you might notice red nodes. Those are simply representing analyzed nodes, while algorithm is looking at all possible nodes for solution.</p>
<p>Now compare that to A* search algorithm, which is same as Dijkstra algorithm, but also takes educated guess while it’s traversing to final node, but bit more about that when we come to A* section.</p>

 <button id="path-finding-reset-2">Reset</button>
    <br>
    <br>
<canvas id="path-finding-canvas-2" width="800" height="600"></canvas>
<script>
"use strict";var _createClass=function(){function e(e,i){for(var a=0;a<i.length;a++){var l=i[a];l.enumerable=l.enumerable||!1,l.configurable=!0,"value"in l&&(l.writable=!0),Object.defineProperty(e,l.key,l)}}return function(i,a,l){return a&&e(i.prototype,a),l&&e(i,l),i}}();function _classCallCheck(e,i){if(!(e instanceof i))throw new TypeError("Cannot call a class as a function")}var example2Module=function(e){var i=null,a=[],l=void 0,n=void 0,r=[],o=[],t=[],s=void 0,f=void 0,u=!1,c=20,g=30,h=function(){function e(i,a){_classCallCheck(this,e),this.gridX=i,this.gridY=a,this.color="white",this.parent=null,this.f=0,this.g=0,this.h=0,this.isWall=Math.random()>.8,this.isDiagonalMove=!1}return _createClass(e,[{key:"draw",value:function(e){e.fillStyle=this.color,e.fillRect(this.gridX*s,this.gridY*f,s-1,f-1)}}]),e}(),v=function(){var v=i.getContext("2d");s=i.width/g,f=i.height/c,a=[],l=null,n=null;for(var d=0;d<g;d++){a[d]=[];for(var p=0;p<c;p++)a[d][p]=new h(d,p),a[d][p].isWall||l||(l=a[d][p])}for(d=g-1;d>=0;d--){for(p=c-1;p>=0&&((n=a[d][p]).isWall&&(n=null),null==n);p--);if(null!=n)break}t=[l],o=[];!function l(){v.fillStyle="black",v.fillRect(0,0,i.width,i.height);for(var s=0;s<g;s++)for(var f=0;f<c;f++){var h=a[s][f];h.color="white",h.isWall&&(h.color="black"),h.draw(v)}if(t.length>0&&!u){var d=_.minBy(t,function(e){return e.f});if(_.remove(t,d),o.push(d),!u){d===n&&(u=!0);var p=d;for(r=[p];null!==p.parent;)p=p.parent,r.push(p);u||0!==t.length||(r=[])}for(var m=(b=[],C=(Y=d).gridX,E=Y.gridY,T=!0,I=!0,B=!0,L=!0,Y.gridX>0&&!a[C-1][E].isWall?(b.push(a[C-1][E]),a[C-1][E].isDiagonalMove=!1):(T=!1,I=!1),Y.gridX<g-1&&!a[C+1][E].isWall?(b.push(a[C+1][E]),a[C+1][E].isDiagonalMove=!1):(B=!1,L=!1),Y.gridY>0&&!a[C][E-1].isWall?(b.push(a[C][E-1]),a[C][E-1].isDiagonalMove=!1):(I=!1,L=!1),Y.gridY<c-1&&!a[C][E+1].isWall?(b.push(a[C][E+1]),a[C][E+1].isDiagonalMove=!1):(T=!1,B=!1),L&&!a[C+1][E-1].isWall&&(b.push(a[C+1][E-1]),a[C+1][E-1].isDiagonalMove=!0),I&&!a[C-1][E-1].isWall&&(b.push(a[C-1][E-1]),a[C-1][E-1].isDiagonalMove=!0),B&&!a[C+1][E+1].isWall&&(b.push(a[C+1][E+1]),a[C+1][E+1].isDiagonalMove=!0),T&&!a[C-1][E+1].isWall&&(b.push(a[C-1][E+1]),a[C-1][E+1].isDiagonalMove=!0),b),W=0;W<m.length;W++){var M=m[W];if(!_.includes(o,M)){M.g=d.g+(M.isDiagonalMove?1.5:1),M.h=(D=n,k=(y=M).gridX-D.gridX,X=y.gridY-D.gridY,Math.sqrt(k*k+X*X)),M.f=M.g+M.h;var w=_.indexOf(t,M);if(w<0)t.push(M);else if(M.g>=t[w].g)continue;M.parent=d}}}var y,D,k,X,Y,b,C,E,T,I,B,L;_.forEach(o,function(e){e.color="red",e.draw(v)}),_.forEach(r,function(e){e.color="green",e.draw(v)}),e.requestAnimationFrame(l)}()};return{onload:function(){i=e.document.getElementById("path-finding-canvas-2"),e.document.getElementById("path-finding-reset-2").onclick=function(){v()},v()},onmousemove:function(h){var v=e.document.getElementsByTagName("main")[0],d=h.pageX-i.offsetLeft+v.scrollLeft,p=h.pageY-i.offsetTop+v.scrollTop,m=parseInt(d/s),W=parseInt(p/f);if(a[m]&&a[m][W]&&!a[m][W].isWall&&n!==a[m][W]){r=[],t=[l],o=[],n=a[m][W],u=!1;for(var M=0;M<g;M++)for(var w=0;w<c;w++)a[M][w].parent=null}},onclick:function(n){var h=e.document.getElementsByTagName("main")[0],v=n.pageX-i.offsetLeft+h.scrollLeft,d=n.pageY-i.offsetTop+h.scrollTop,p=parseInt(v/s),m=parseInt(d/f);if(a[p]&&a[p][m]&&!a[p][m].isWall&&l!==a[p][m]){r=[],l=a[p][m],t=[l],o=[],u=!1;for(var W=0;W<g;W++)for(var M=0;M<c;M++)a[W][M].parent=null}}}};
</script>

<p>You might already have an idea of how algorithm works.</p>
<p>There is obviously a starting and an ending position, let’s call those starting and ending node. Going from start node,<br>algorithm takes all nodes surrounding it. Those nodes have some movement cost assigned to them. As example if you’re driving from one city to other, there is a cost of that ride, same is here. For example moving from node A to node B can cost 7 units. Unit is just arbitrary number in this case, but it can represent distance from one city to another if algorithm is used for geo location service.</p>
<p>Let’s take a look at the following image. This is simple as it gets. There is a starting node “S”, nodes “A” and “B” in between and an ending node “E”.</p>
<p><img src="/images/12/image1.png" style="width:50%"></p>
<p>From starting node “S” we can go to nodes “A” and “B”. From those nodes we can move towards the end “E”. It’s easy to see that move S-&gt;A-&gt;E is preffered path, since it’s total cost is 5. S-&gt;A is 2 units and A-&gt;E is 3 units. Lower cost path is a better path.</p>
<p>But take into consideration moving between “A” and “B” could alsp be possible. </p>
<p><img src="/images/12/image2.png" style="width:50%"></p>
<p>As you can see there are 4 possible paths now.</p>
<ul>
<li>S-&gt;A-&gt;E with total cost of 5.</li>
<li>S-&gt;A-&gt;B-&gt;E with total cost of 6.</li>
<li>S-&gt;B-&gt;E with total cost of 6.</li>
<li>S-&gt;B-&gt;A-&gt;E with total cost of 9.</li>
</ul>
<p>S-&gt;A-&gt;E is still preferred path since it’s shortest.</p>
<p>Important thing to note in algorithm, once node is analyzed there is no going back.<br>That essentially means that once the path from S-&gt;A and S-&gt;B are analyzed we cannot return to node S.</p>
<p>Also note that Dijkstra algorithm assumes, that all nodes, except for staring node, initally have cost of infinity.<br>Cost of starting node is actually 0.</p>
<p>Looking at example here there is a starting node and other nodes with cost of infinity.</p>
<p><img src="/images/12/image3.png" style="width:50%"></p>
<p>When algorithm analyzes node S, it finds two neighbours A and B.<br>It moves forward to the neighbour with lower cost,which is A. A now gets a cost of 2.</p>
<p><img src="/images/12/image4.png" style="width:50%"></p>
<p>On next step, we pick node B and assign cost of 4 to it. S node is closed since all of it’s neigbours are analyzed and we can never return to it.</p>
<p><img src="/images/12/image5.png" style="width:50%"></p>
<p>Going further again node A with lower cost is picked. Algorithm check’s it’s path to E and closes it, since it doesn’t have any other neighbours.</p>
<p><img src="/images/12/image6.png" style="width:50%"></p>
<p>It does the same thing for B, but path through A has lower cost, so it becomes final path, as indicated with blue arrows.</p>
<p><img src="/images/12/image7.png" style="width:50%"></p>
<p>Try out this example to see concept for yourself. You can move steps by clicking next or anywhere else on the image.<br>Also example assumes that cost of straight move is 1 unit while cost of diagonal move is 1.5 units.</p>

 <button id="path-finding-reset-4">Reset</button>
 <button id="path-finding-next-4">Next move</button>
    <br>
    <br>
<canvas id="path-finding-canvas-4" width="600" height="450"></canvas>
<script>
"use strict";var _createClass=function(){function r(r,n){for(var e=0;e<n.length;e++){var o=n[e];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(r,o.key,o)}}return function(n,e,o){return e&&r(n.prototype,e),o&&r(n,o),n}}();function _classCallCheck(r,n){if(!(r instanceof n))throw new TypeError("Cannot call a class as a function")}var example4Module=function(r){var n=null,e=[],o=void 0,i=void 0,t=[],l=[],a=[],u=void 0,c=void 0,f=!1,h=null,d=function(){function r(n,e){_classCallCheck(this,r),this.gridX=n,this.gridY=e,this.color="white",this.parent=null,this.f=0,this.g=0,this.h=0}return _createClass(r,[{key:"draw",value:function(r){r.fillStyle=this.color,r.fillRect(this.gridX*u,this.gridY*c,u-1,c-1),r.font="24px Arial",r.fillStyle="black",r.fillText(this.g,this.gridX*u+.2*u,this.gridY*c+.5*c)}}]),r}(),s=function(){h=n.getContext("2d"),u=n.width/5,c=n.height/5,e=[],l=[],a=[],t=[],f=!1,o=null;for(var r=0;r<5;r++){e[r]=[];for(var s=0;s<5;s++)e[r][s]=new d(r,s),e[r][s].g=1/0,null==o&&((o=e[r][s]).g=0)}for(r=4;r>=0;r--){for(s=4;s>=0&&null==(i=e[r][s]);s--);if(null!=i)break}for(r=0;r<5;r++)for(s=0;s<5;s++)l.push(e[r][s]);h.fillStyle="black",h.fillRect(0,0,n.width,n.height);for(r=0;r<5;r++)for(s=0;s<5;s++){var g=e[r][s];g.color="white",g.draw(h)}},g=function(){var r,u,c,d,s,g,v,p,w=null,y=null;if(h.fillStyle="black",h.fillRect(0,0,n.width,n.height),l.length>0&&!f){if(w=_.minBy(l,function(r){return r.g}),_.remove(l,w),!f){t=[],w==i&&(f=!0);var k=w;for(t.push(k);k.parent;)t.push(k.parent),k=k.parent;k!=o&&(t=[])}y=_.filter((u=[],c=(r=w).gridX,d=r.gridY,s=!0,g=!0,v=!0,p=!0,r.gridX>0?(e[c-1][d].diagonalMove=!1,u.push(e[c-1][d])):(s=!1,g=!1),r.gridX<4?(e[c+1][d].diagonalMove=!1,u.push(e[c+1][d])):(v=!1,p=!1),r.gridY>0?(e[c][d-1].diagonalMove=!1,u.push(e[c][d-1])):(g=!1,p=!1),r.gridY<4?(e[c][d+1].diagonalMove=!1,u.push(e[c][d+1])):(s=!1,v=!1),p&&(e[c+1][d-1].diagonalMove=!0,u.push(e[c+1][d-1])),g&&(e[c-1][d-1].diagonalMove=!0,u.push(e[c-1][d-1])),v&&(e[c+1][d+1].diagonalMove=!0,u.push(e[c+1][d+1])),s&&(e[c-1][d+1].diagonalMove=!0,u.push(e[c-1][d+1])),u));for(var M=0;M<y.length;M++){var b=y[M],m=w.g+(b.diagonalMove?1.5:1);m<b.g&&(b.g=m,b.parent=w)}w&&a.push(w)}for(var C=0;C<5;C++)for(var X=0;X<5;X++){var Y=e[C][X];Y.color="white",Y.draw(h)}_.forEach(a,function(r){r.color="red",r.draw(h)}),w&&(w.color="blue",w.draw(h)),w==i&&_.forEach(t,function(r){r.color="green",r.draw(h)})};return{onclick:function(){f||g()},onload:function(){n=document.getElementById("path-finding-canvas-4"),document.getElementById("path-finding-reset-4").onclick=function(){s()},s()}}};
</script>

<p>On each step surrounding nodes get analzyed and new cost is assigned to them. That cost is cost of previous nodes + path to current node.</p>
<p>That’s short explanation of Dijkstra algorithm.</p>
<p><br></p>
<h5 id="A-Search"><a href="#A-Search" class="headerlink" title="A* Search"></a>A* Search</h5><p>Now that you know how Dijkstra Algorithm works, it’s time to see it’s drawback and how A* improves upon it.</p>
<p>Take a look at next example of Dijkstra Algorithm. Use <em>Next move</em> button or simply start clicking on image until the node reaches end.</p>

 <button id="path-finding-reset-5">Reset</button>
 <button id="path-finding-next-5">Next move</button>
    <br>
    <br>
<canvas id="path-finding-canvas-5" width="600" height="400"></canvas>
<script>
"use strict";var _createClass=function(){function t(t,r){for(var i=0;i<r.length;i++){var e=r[i];e.enumerable=e.enumerable||!1,e.configurable=!0,"value"in e&&(e.writable=!0),Object.defineProperty(t,e.key,e)}}return function(r,i,e){return i&&t(r.prototype,i),e&&t(r,e),r}}();function _classCallCheck(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}var example5Module=function(t){var r=null,i=[],e=void 0,n=void 0,l=[],o=[],a=[],h=void 0,c=void 0,s=!1,f=null,u=function(){function t(r,i){_classCallCheck(this,t),this.gridX=r,this.gridY=i,this.color="white",this.parent=null,this.f=0,this.g=0,this.h=0}return _createClass(t,[{key:"draw",value:function(t){this.canDraw&&(t.fillStyle=this.color,t.fillRect(this.gridX*h,this.gridY*c,h-1,c-1),t.font="20px Arial",this.start?this.text="S: "+this.g:this.end?this.text="E: "+(this.g>=1/0?"Inf":this.g):this.g>=1/0?this.text="Inf":this.text=this.g,t.fillStyle="black",t.fillText(this.text,this.gridX*h+.2*h,this.gridY*c+.5*c))}}]),t}(),d=function(t,r){return 2===r||(4===t&&r>=2||r<=2&&(0===t||8===t))},g=function(){f=r.getContext("2d"),h=r.width/9,c=r.height/5,i=[],o=[],a=[],l=[],s=!1,e=null;for(var t=0;t<9;t++){i[t]=[];for(var g=0;g<5;g++)i[t][g]=new u(t,g),i[t][g].g=1/0,d(t,g)&&(i[t][g].canDraw=!0)}(e=i[4][4]).start=!0,e.g=0,(n=i[8][0]).end=!0;for(t=0;t<9;t++)for(g=0;g<5;g++)d(t,g)&&o.push(i[t][g]);f.fillStyle="black",f.fillRect(0,0,r.width,r.height);for(t=0;t<9;t++)for(g=0;g<5;g++){var v=i[t][g];v.color="white",v.draw(f)}n.color="lightblue",n.draw(f)},v=function(){var t,h,c,u,g=null,v=null;if(f.fillStyle="black",f.fillRect(0,0,r.width,r.height),o.length>0){if(g=_.minBy(o,function(t){return t.g}),_.remove(o,g),!s){l=[],g==n&&(s=!0);var p=g;for(l.push(p);p.parent;)l.push(p.parent),p=p.parent;p!=e&&(l=[])}v=_.filter((h=[],c=(t=g).gridX,u=t.gridY,t.gridX>0&&d(c-1,u)&&h.push(i[c-1][u]),t.gridX<8&&d(c+1,u)&&h.push(i[c+1][u]),t.gridY>0&&d(c,u-1)&&h.push(i[c][u-1]),t.gridY<4&&d(c,u+1)&&h.push(i[c][u+1]),h));for(var w=0;w<v.length;w++){var y=v[w],b=g.g+(y.diagonalMove?1.5:10);b<y.g&&(y.g=b,y.parent=g)}g&&a.push(g)}for(var k=0;k<9;k++)for(var m=0;m<5;m++){var x=i[k][m];x.color="white",x.draw(f)}_.forEach(a,function(t){t.color="red",t.draw(f)}),g&&(g.color="blue",g.draw(f)),n.color="lightblue",n.draw(f),g==n&&_.forEach(l,function(t){t.color="green",t.draw(f)})};return{onload:function(){r=document.getElementById("path-finding-canvas-5"),document.getElementById("path-finding-reset-5").onclick=function(){g()},g()},onclick:function(){s||v()}}};
</script>

<p>Wow :) , that is a bunch of steps on both sides.<br>Compare that to A* search. You already know everything, click <em>Next move</em> or image to advance.</p>


 <button id="path-finding-reset-6">Reset</button>
  <button id="path-finding-next-6">Next move</button>
    <br>
    <br>
<canvas id="path-finding-canvas-6" width="600" height="400"></canvas>
<script>
"use strict";var _createClass=function(){function t(t,i){for(var r=0;r<i.length;r++){var e=i[r];e.enumerable=e.enumerable||!1,e.configurable=!0,"value"in e&&(e.writable=!0),Object.defineProperty(t,e.key,e)}}return function(i,r,e){return r&&t(i.prototype,r),e&&t(i,e),i}}();function _classCallCheck(t,i){if(!(t instanceof i))throw new TypeError("Cannot call a class as a function")}var example6Module=function(t){var i=null,r=[],e=void 0,n=void 0,l=[],o=[],a=[],h=void 0,c=void 0,s=!1,f=null,u=function(){function t(i,r){_classCallCheck(this,t),this.gridX=i,this.gridY=r,this.color="white",this.parent=null,this.f=0,this.g=0,this.h=0}return _createClass(t,[{key:"draw",value:function(t){this.canDraw&&(t.fillStyle=this.color,t.fillRect(this.gridX*h,this.gridY*c,h-1,c-1),t.font="20px Arial",this.start?this.text="S: "+this.g:this.end?this.text="E: "+(this.g>=1/0?"Inf":this.g):this.g>=1/0?this.text="Inf":this.text=this.g,t.fillStyle="black",t.fillText(this.text,this.gridX*h+.2*h,this.gridY*c+.5*c))}}]),t}(),d=function(t,i){return 2===i||(4===t&&i>=2||i<=2&&(0===t||8===t))},g=function(){f=i.getContext("2d"),h=i.width/9,c=i.height/5,r=[],o=[],a=[],l=[],s=!1,e=null;for(var t=0;t<9;t++){r[t]=[];for(var g=0;g<5;g++)r[t][g]=new u(t,g),d(t,g)&&(r[t][g].canDraw=!0)}(e=r[4][4]).start=!0,e.g=0,(n=r[8][0]).end=!0,o=[e],f.fillStyle="black",f.fillRect(0,0,i.width,i.height);for(t=0;t<9;t++)for(g=0;g<5;g++){var v=r[t][g];v.color="white",v.draw(f)}n.color="lightblue",n.draw(f)},v=function(){var t,h,c,u,g,v,p,w,y=null,b=null;if(f.fillStyle="black",f.fillRect(0,0,i.width,i.height),o.length>0){if(y=_.minBy(o,function(t){return t.f}),_.remove(o,y),!s){l=[],y==n&&(s=!0);var x=y;for(l.push(x);x.parent;)l.push(x.parent),x=x.parent;x!=e&&(l=[])}b=_.filter((v=[],p=(g=y).gridX,w=g.gridY,g.gridX>0&&d(p-1,w)&&v.push(r[p-1][w]),g.gridX<8&&d(p+1,w)&&v.push(r[p+1][w]),g.gridY>0&&d(p,w-1)&&v.push(r[p][w-1]),g.gridY<4&&d(p,w+1)&&v.push(r[p][w+1]),v)),y&&a.push(y);for(var k=0;k<b.length;k++){var m=b[k];if(!_.includes(a,m)){m.g=y.g+(m.diagonalMove?1.5:10),m.h=(h=n,void 0,void 0,c=(t=m).gridX-h.gridX,u=t.gridY-h.gridY,10*Math.sqrt(c*c+u*u)),m.f=m.g+m.h;var C=_.indexOf(a,m);if(C<0)o.push(m);else if(m.g>=o[C].g)continue;m.parent=y}}}for(var X=0;X<9;X++)for(var Y=0;Y<5;Y++){var E=r[X][Y];E.color="white",E.draw(f)}_.forEach(a,function(t){t.color="red",t.draw(f)}),y&&(y.color="blue",y.draw(f)),n.color="lightblue",n.draw(f),y==n&&_.forEach(l,function(t){t.color="green",t.draw(f)})};return{onclick:function(){s||v()},onload:function(){i=document.getElementById("path-finding-canvas-6"),document.getElementById("path-finding-reset-6").onclick=function(){g()},g()}}};
</script>
 
<p>Only checks one side! Why?</p>
<p> That’s because A* search also uses educated guess when it evaluates cost of nodes. But what does that mean ?</p>
<p>Educated guess in this case is distance. That means that algorithm takes into account nodes distance from final node. If it’s closer to final, it prefers that node.</p>
<p>Final node cost therefore is, sum of cost of path and heuristic. It can be expressed like this.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(n) = g(n) + h(n)</span><br><span class="line"><span class="comment">// f(n) is total cost of node. g(n) is cost of path + h(n) which represents heuristic or educated guess.</span></span><br></pre></td></tr></table></figure>
<p>Example is going to  make it a bit more clear. You know the drill.</p>


 <button id="path-finding-reset-7">Reset</button>
  <button id="path-finding-next-7">Next move</button>
    <br>
    <br>
<canvas id="path-finding-canvas-7" width="600" height="400"></canvas>
<script>
"use strict";var _createClass=function(){function i(i,r){for(var t,e=0;e<r.length;e++)t=r[e],t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(i,t.key,t)}return function(r,t,e){return t&&i(r.prototype,t),e&&i(r,e),r}}();function _classCallCheck(i,r){if(!(i instanceof r))throw new TypeError("Cannot call a class as a function")}var example7Module=function(){var i,r,t,e,n=null,l=[],o=[],a=[],h=[],f=!1,c=null,s=function(){function i(r,t){_classCallCheck(this,i),this.gridX=r,this.gridY=t,this.color="white",this.parent=null,this.f=0,this.g=0,this.h=0}return _createClass(i,[{key:"draw",value:function(i){this.canDraw&&(i.fillStyle=this.color,i.fillRect(this.gridX*t,this.gridY*e,t-1,e-1),i.font="14px Arial",i.fillStyle="black",i.fillText("G: "+this.g,this.gridX*t+.2*t,this.gridY*e+.2*e),i.fillText("H: "+parseInt(this.h),this.gridX*t+.2*t,this.gridY*e+.5*e),i.fillText("F: "+parseInt(this.f),this.gridX*t+.2*t,this.gridY*e+.8*e))}},{key:"drawLine",value:function(i,r){i.beginPath(),i.strokeStyle="yellow",i.moveTo(this.gridX*t+.5*t,this.gridY*e+.5*e),i.lineTo(r.gridX*t+.5*t,r.gridY*e+.5*e),i.stroke(),i.font="18px Arial",i.fillStyle="yellow",i.fillText(parseInt(this.h),(this.gridX+r.gridX)/2*t,(this.gridY+r.gridY+1)/2*e)}}]),i}(),d=function(i,r){return 2===r||(4===i&&2<=r||2>=r&&(0===i||8===i))},u=function(){c=n.getContext("2d"),t=n.width/9,e=n.height/5,l=[],a=[],h=[],o=[],f=!1,i=null;for(var u=0;u<9;u++){l[u]=[];for(var g=0;g<5;g++)l[u][g]=new s(u,g),d(u,g)&&(l[u][g].canDraw=!0)}(i=l[4][4]).start=!0,i.g=0,(r=l[8][0]).end=!0,a=[i],c.fillStyle="black",c.fillRect(0,0,n.width,n.height);for(u=0;u<9;u++){var p;for(g=0;g<5;g++)p=l[u][g],p.color="white",p.draw(c)}r.color="lightblue",r.draw(c)},g=function(){var t,e,s,u,g,p,w,v,y=null,X=null;if(c.fillStyle="black",c.fillRect(0,0,n.width,n.height),0<a.length){if(y=_.minBy(a,function(i){return i.f}),_.remove(a,y),!f){o=[],y==r&&(f=!0);var Y=y;for(o.push(Y);Y.parent;)o.push(Y.parent),Y=Y.parent;Y!=i&&(o=[])}X=_.filter((p=[],w=(g=y).gridX,v=g.gridY,0<g.gridX&&d(w-1,v)&&p.push(l[w-1][v]),g.gridX<8&&d(w+1,v)&&p.push(l[w+1][v]),0<g.gridY&&d(w,v-1)&&p.push(l[w][v-1]),g.gridY<4&&d(w,v+1)&&p.push(l[w][v+1]),p)),y&&h.push(y);for(var b,k=0;k<X.length;k++)if(b=X[k],!_.includes(h,b)){b.g=y.g+(b.diagonalMove?1.5:10),b.h=(e=r,void 0,void 0,s=(t=b).gridX-e.gridX,u=t.gridY-e.gridY,10*Math.sqrt(s*s+u*u)),b.f=b.g+b.h;var m=_.indexOf(h,b);if(0>m)a.push(b);else if(b.g>=a[m].g)continue;b.parent=y}}for(var x=0;x<9;x++)for(var C,T=0;T<5;T++)C=l[x][T],C.color="white",C.draw(c);_.forEach(h,function(i){i.color="red",i.draw(c)}),y&&(y.color="blue",y.draw(c)),r.color="lightblue",r.draw(c),y==r&&_.forEach(o,function(i){i.color="green",i.draw(c)}),_.forEach(a,function(i){i!=r&&i.drawLine(c,r)})};return{onload:function(){n=document.getElementById("path-finding-canvas-7"),document.getElementById("path-finding-reset-7").onclick=function(){u()},u()},onclick:function(){f||g()}}};
</script>

<p><br></p>
<p>That’s it.</p>
<h5 id="Code-and-implementation"><a href="#Code-and-implementation" class="headerlink" title="Code and implementation"></a>Code and implementation</h5><p>Time to code :)</p>
<p> Disclaimer first, I’m going to write code with new JavaScript features, so I do recommend upgrading your browser to latest version or using compiler like Babel, to compile it to older version if you do not want to upgrade. I’m simply using newer version, to avoid some JavaScript nestiness and quirks, for those who are not familiar with it.</p>
<p>Some knowledge of JS is required though, just for basic html page and linking javaScript scripts. Also if you want you can code examples with online editors such as <a href="https://codepen.io/" target="_blank" rel="noopener">codepen</a>.</p>
<p>We need to have html file of course.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Path Finding<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/lodash@4.17.11/lodash.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"render-canvas"</span> <span class="attr">width</span>=<span class="string">"800"</span> <span class="attr">height</span>=<span class="string">"600"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>If you look at the script tags, you might notice that I’m using <a href="https://lodash.com/" target="_blank" rel="noopener">lodash</a>. It’s simple JS library for working with arrays, collections, objects etc… It can be done with vanilla js, but things like removing objects and finding minimum value are still bit weird and not really intuitive, therefore lodash :)s</p>
<p>Seconds file that you need to have is <em>main.js</em> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Globals</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="literal">null</span>,</span><br><span class="line">    ctx = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Draws to screen</span></span><br><span class="line"><span class="keyword">const</span> draw = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    ctx.fillStyle = <span class="string">"black"</span>;</span><br><span class="line">    ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render loop</span></span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// On browser load</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    canvas = <span class="built_in">document</span>.getElementById(<span class="string">"render-canvas"</span>);</span><br><span class="line">    ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">    draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When mouse is clicked</span></span><br><span class="line"><span class="built_in">window</span>.onclick = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When mouse is moved</span></span><br><span class="line"><span class="built_in">window</span>.onmousemove = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I have defined couple of things, first there is section for global variables. <a href="https://www.w3schools.com/html/html5_canvas.asp" target="_blank" rel="noopener">Canvas</a> is drawing surface in html. <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D" target="_blank" rel="noopener">2d context</a> is a context for handling 2d graphics in html. There is also <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API" target="_blank" rel="noopener">webgl context</a> for handling 3d and 2d graphics.</p>
<p>Draw function, as name already says will handle all the drawing.  <em>requestAnimationFrame(draw);</em> makes sure that draw function is looped. For more about <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="noopener">requestAnimationFrame click this</a>.</p>
<p>Example is going to be explained in steps, instead coding everything in advance.</p>
<pre><code>* creating and drawing a grid
* adding direct movement
* adding obstacles
* adding diagonal movement
* mouse move and click
</code></pre><p>Starting with grid. Width and height of each grid node need to be defined. We also need number of rows and columns in a grid and array that’s going to hold all nodes. On top of that each node can be represented with class. So add following globals.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Globals</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="literal">null</span>,</span><br><span class="line">    ctx = <span class="literal">null</span>,</span><br><span class="line">    nodeWidth = <span class="literal">null</span>,</span><br><span class="line">    nodeHeight = <span class="literal">null</span>,</span><br><span class="line">    nodes = [],</span><br><span class="line">    rows = <span class="number">30</span>,</span><br><span class="line">    cols = <span class="number">40</span>;</span><br></pre></td></tr></table></figure>
<p>and right below that create a class <em>Node</em>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.gridX = x;</span><br><span class="line">        <span class="keyword">this</span>.gridY = y;</span><br><span class="line">        <span class="keyword">this</span>.color = <span class="string">"white"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    draw() &#123;</span><br><span class="line">        ctx.fillStyle = <span class="keyword">this</span>.color;</span><br><span class="line">        ctx.fillRect(<span class="keyword">this</span>.gridX * nodeWidth, <span class="keyword">this</span>.gridY * nodeHeight, nodeWidth - <span class="number">1</span>, nodeHeight - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Node</em> is quite simple class, it has properties <em>gridX</em> and <em>gridY</em> which represent row and column position within grid. In <em>draw</em> function we set the color for a rectangle that’s going to represent node, in this case white.</p>
<p> <em>fillRect</em> takes position x, position y, width and height as properties.</p>
<p> Width and height are subtracted by 1, just so that there can be small offset between nodes.</p>
<p>Next piece of code is <em>onload</em> method, which is starting point of application, it also handles creation of nodes, canvas etc… Nodes array is actually array of arrays, or 2 dimensional array.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// On browser load</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    canvas = <span class="built_in">document</span>.getElementById(<span class="string">"render-canvas"</span>);</span><br><span class="line">    ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">    nodeWidth = canvas.width / cols;</span><br><span class="line">    nodeHeight = canvas.height / rows;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; cols; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        nodes[x] = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; rows;y++)</span><br><span class="line">        &#123;</span><br><span class="line">            nodes[x][y] = <span class="keyword">new</span> Node(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Notice <em>nodeWidth</em> and <em>nodeHeight</em> being set in <em>onload</em> call.<br><em>Draw</em> function looks like this now.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Draws to screen</span></span><br><span class="line"><span class="keyword">const</span> draw = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    ctx.fillStyle = <span class="string">"black"</span>;</span><br><span class="line">    ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; cols; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; rows;y++)</span><br><span class="line">        &#123;</span><br><span class="line">            nodes[x][y].draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render loop</span></span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>With all of that, you should have following drawn on screen.</p>
<p><img src="/images/12/image8.png" style="width:75%"></p>
<h6 id="Direct-Movement"><a href="#Direct-Movement" class="headerlink" title="Direct Movement"></a>Direct Movement</h6><p>Time to add direct movement. First step would be to expand node class with additional properties. Expand <em>Node</em> class in  constructors with following properties.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">       <span class="keyword">this</span>.gridX = x;</span><br><span class="line">       <span class="keyword">this</span>.gridY = y;</span><br><span class="line">       <span class="keyword">this</span>.color = <span class="string">"white"</span>;</span><br><span class="line">       <span class="keyword">this</span>.g = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">this</span>.h = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">this</span>.f = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">this</span>.parent = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><em>G, h</em> and <em>f</em> properties are cost related properties. Cost property <em>g</em> is sum of all moves iš to that node. Property <em>h</em> will be cost of heuristic and property <em>f</em> sum of <em>g</em> and <em>h</em>.</p>
<p><em>Parent</em> property will hold previous node. It’s going to become clear how it works once we get to algorithm part.</p>
<p>Next we’re going to need variable <em>path</em> which is array of nodes that make final path. Also add start and end node variables.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Globals</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="literal">null</span>,</span><br><span class="line">    ctx = <span class="literal">null</span>,</span><br><span class="line">    nodeWidth = <span class="literal">null</span>,</span><br><span class="line">    nodeHeight = <span class="literal">null</span>,</span><br><span class="line">    nodes = [],</span><br><span class="line">    rows = <span class="number">30</span>,</span><br><span class="line">    cols = <span class="number">40</span>,</span><br><span class="line">    path = [],              <span class="comment">// notice path</span></span><br><span class="line">    startNode = <span class="literal">null</span>,       <span class="comment">// startNode</span></span><br><span class="line">    endNode = <span class="literal">null</span>;         <span class="comment">// endNode</span></span><br></pre></td></tr></table></figure>
<p>In <em>onload</em> function, right after double for loop, but before <em>draw()</em> call add following</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Skip for loop, this was added previously.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; cols; x++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add these.</span></span><br><span class="line">startNode = nodes[<span class="number">0</span>][<span class="number">0</span>];                <span class="comment">// top left node</span></span><br><span class="line">endNode = nodes[cols<span class="number">-1</span>][rows<span class="number">-1</span>];        <span class="comment">// bottom right node</span></span><br><span class="line">path = findPath();</span><br><span class="line"></span><br><span class="line">draw(); <span class="comment">// defined previously, you don't need to add it</span></span><br></pre></td></tr></table></figure>
<p>You might notice <em>findPath()</em> call here, which still isn’t defined. That method is main part of algorithm.<br>Define <em>findPath</em> method and add following.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findPath = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> closedSet = [];</span><br><span class="line">    <span class="keyword">const</span> openSet = [startNode];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Names of these arrays are self explanatory, <em>closedSet</em> will contain all nodes that we have analyzed by the end of algorithm, <em>openSet</em> for start contains only starting position, but gets expanded as new nodes are added and old removed.</p>
<p>Right after that add</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> currentNode = _.minBy(openSet, x =&gt; x.f);</span><br><span class="line"></span><br><span class="line">_.remove(openSet, currentNode);</span><br><span class="line">closedSet.push(currentNode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> neighbourNodes = getAdjecentNodes(currentNode);</span><br></pre></td></tr></table></figure>
<p>First line finds node with lowest total cost <em>f</em>. You might rember that <em>f</em> is sum of costs <em>g</em> and <em>h</em>.</p>
<p>After finding it, it gets removed from <em>openSet</em> and pushed to <em>closedSet</em>. Pushing it to closed set will make sure that it never ends up in <em>openSet</em> again, because we do not want to analyzed same node again.</p>
<p>Next, new function <em>getNeighbourNodes</em> is added. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getNeighbourNodes = <span class="function"><span class="params">currentNode</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> neighbourNodes = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> x = currentNode.gridX,</span><br><span class="line">        y = currentNode.gridY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x - <span class="number">1</span>][y]);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; cols - <span class="number">1</span> ) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x + <span class="number">1</span>][y]);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x][y - <span class="number">1</span>]);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y &lt; rows - <span class="number">1</span>) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x][y + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> neighbourNodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This checks for all neighbours of a current node. Checks like <em>x &gt; 0</em> are just making sure that we do not try to get  something that is not defined in nodes array. </p>
<p>Next we need to loop through those neighbour nodes </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; neighbourNodes.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> neighbourNode = neighbourNodes[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_.includes(closedSet,neighbourNode))&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>As I have mentioned, nodes that are in closed set should not be analyzed. <em>Includes</em> checks if node is already in closed set,if so, it skips to next iterator. Add following after if block.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">neighbourNode.g = currentNode.g + moveCost;</span><br><span class="line">neighbourNode.h = heuristic(neighbourNode, endNode);</span><br><span class="line">neighbourNode.f = neighbourNode.g + neighbourNode.h;</span><br></pre></td></tr></table></figure>
<p>Couple of things here. Nodes <em>g</em> cost is sum of previous node <em>g</em> and some general move cost. We’re going to define <em>moveCost</em> as a global constant. At the beginning of <em>js</em> file, right after end node add this.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... </span></span><br><span class="line">endNode = <span class="literal">null</span>,</span><br><span class="line">moveCost = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><em>H</em> is cost of heuristic or educated guess. This is main difference when compared to Dijkstra algorithm.<br>Heuristic can be just about anything, but in this case, it’s simply going to be a distance.</p>
<p>So time to add our heuristic functions which is just <a href="https://en.wiktionary.org/wiki/Manhattan_distance" target="_blank" rel="noopener">Manhattan distance</a> or otherwise called <a href="https://en.wikipedia.org/wiki/Taxicab_geometry" target="_blank" rel="noopener">Taxi cab distance</a>. It is called that way because it works with blocks. Later, when we add diagonal movement to our code, function is going to be changed to <a href="https://en.wikipedia.org/wiki/Euclidean_distance" target="_blank" rel="noopener">Euclidian distance</a>. If it’s still bit unclear what’s the difference, imagine traveling by air vs traveling by rode. With air travel you move from A to B directly, without anything to block your path,  and that is Euclidian distance. On road, there are roads and paths, which prevent straigh forward travel. That’s Manhattan or Taxi cab distance. </p>
<p>So add <em>heuristic</em> function to your code, but make sure that it’s outside of <em>findPath</em> function.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> heuristic = <span class="function">(<span class="params">nodeA, nodeB</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dx = <span class="built_in">Math</span>.abs(nodeA.gridX - nodeB.gridX);</span><br><span class="line">    <span class="keyword">const</span> dy = <span class="built_in">Math</span>.abs(nodeA.gridY - nodeB.gridY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dx + dy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Add following after <em>neighbour.f = …</em> line.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> index = _.indexOf(openSet, neighbourNode);</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    openSet.push(neighbourNode);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (neighbourNode.g &gt;= openSet[index].g) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">neighbourNode.parent = currentNode;</span><br></pre></td></tr></table></figure>
<p><em>IndexOf</em> gets index of <em>neighbourNode</em> in <em>openSet</em>. If it’s less then 0, node is not found, so it’s added to <em>openSet</em>.<br>However, if it is found, <em>else if</em> wil check <em>g</em> cost of node. If there is node with lower cost in <em>openSet</em> do nothing and <em>continue</em> loop to next iteration.</p>
<p>This part is where <em>parent</em> is set. This makes sure that we keep track of parent/previous node.</p>
<p>Right after <em>for</em> loop for neighbour nodes add following.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentNode === endNode) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> endPath = [currentNode];</span><br><span class="line">    currentNode = currentNode.parent;</span><br><span class="line">    <span class="keyword">while</span> (currentNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">        endPath.push(currentNode);</span><br><span class="line">        currentNode = currentNode.parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> endPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This code checks if current node is a end node. If so adds current node <em>endPath</em> and travers all nodes until parent does  no longer exists. Add each parent node to path. Node without parent is actually start node, given that path is found of course.</p>
<p>After big <em>while</em> loop just return empty array. This will be returned in case that path is not found.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [];</span><br></pre></td></tr></table></figure>
<p>Final step is to draw found nodes.</p>
<p>In <em>draw</em> loop, right after double <em>for</em> loop, add following.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_.forEach(path, node =&gt; &#123;</span><br><span class="line">    node.color = &quot;green&quot;;</span><br><span class="line">    node.draw();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>This is is for this part, I’m putting all code so far for reference.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Globals</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="literal">null</span>,</span><br><span class="line">    ctx = <span class="literal">null</span>,</span><br><span class="line">    nodeWidth = <span class="literal">null</span>,</span><br><span class="line">    nodeHeight = <span class="literal">null</span>,</span><br><span class="line">    nodes = [],</span><br><span class="line">    rows = <span class="number">30</span>,</span><br><span class="line">    cols = <span class="number">40</span>,</span><br><span class="line">    path = [],</span><br><span class="line">    startNode = <span class="literal">null</span>,</span><br><span class="line">    endNode = <span class="literal">null</span>,</span><br><span class="line">    moveCost = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.gridX = x;</span><br><span class="line">        <span class="keyword">this</span>.gridY = y;</span><br><span class="line">        <span class="keyword">this</span>.color = <span class="string">"white"</span>;</span><br><span class="line">        <span class="keyword">this</span>.parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.g = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.h = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    draw() &#123;</span><br><span class="line">        ctx.fillStyle = <span class="keyword">this</span>.color;</span><br><span class="line">        ctx.fillRect(<span class="keyword">this</span>.gridX * nodeWidth, <span class="keyword">this</span>.gridY * nodeHeight, nodeWidth - <span class="number">1</span>, nodeHeight - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Draws to screen</span></span><br><span class="line"><span class="keyword">const</span> draw = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    ctx.fillStyle = <span class="string">"black"</span>;</span><br><span class="line">    ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; cols; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; rows; y++) &#123;</span><br><span class="line">            nodes[x][y].draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _.forEach(path, node =&gt; &#123;</span><br><span class="line">        node.color = <span class="string">"green"</span>;</span><br><span class="line">        node.draw();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render loop</span></span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> heuristic = <span class="function">(<span class="params">nodeA, nodeB</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dx = <span class="built_in">Math</span>.abs(nodeA.gridX - nodeB.gridX);</span><br><span class="line">    <span class="keyword">const</span> dy = <span class="built_in">Math</span>.abs(nodeA.gridY - nodeB.gridY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dx + dy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> findPath = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> closedSet = [];</span><br><span class="line">    <span class="keyword">const</span> openSet = [startNode];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (openSet.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentNode = _.minBy(openSet, x =&gt; x.f);</span><br><span class="line"></span><br><span class="line">        _.remove(openSet, currentNode);</span><br><span class="line">        closedSet.push(currentNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> neighbourNodes = getNeighbourNodes(currentNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; neighbourNodes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> neighbourNode = neighbourNodes[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_.includes(closedSet, neighbourNode)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            neighbourNode.g = currentNode.g + moveCost;</span><br><span class="line">            neighbourNode.h = heuristic(neighbourNode, endNode);</span><br><span class="line">            neighbourNode.f = neighbourNode.g + neighbourNode.h;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> index = _.indexOf(openSet, neighbourNode);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                openSet.push(neighbourNode);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (neighbourNode.g &gt;= openSet[index].g) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            neighbourNode.parent = currentNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentNode === endNode) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> endPath = [currentNode];</span><br><span class="line">            <span class="keyword">while</span> (currentNode.parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">                currentNode = currentNode.parent;</span><br><span class="line">                endPath.push(currentNode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> endPath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getNeighbourNodes = <span class="function"><span class="params">currentNode</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> neighbourNodes = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> x = currentNode.gridX,</span><br><span class="line">        y = currentNode.gridY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x - <span class="number">1</span>][y]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; cols - <span class="number">1</span>) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x + <span class="number">1</span>][y]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x][y - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y &lt; rows - <span class="number">1</span>) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x][y + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> neighbourNodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// On browser load</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    canvas = <span class="built_in">document</span>.getElementById(<span class="string">"render-canvas"</span>);</span><br><span class="line">    ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">    nodeWidth = canvas.width / cols;</span><br><span class="line">    nodeHeight = canvas.height / rows;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; cols; x++) &#123;</span><br><span class="line">        nodes[x] = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; rows; y++) &#123;</span><br><span class="line">            nodes[x][y] = <span class="keyword">new</span> Node(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startNode = nodes[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    endNode = nodes[cols - <span class="number">1</span>][rows - <span class="number">1</span>];</span><br><span class="line">    path = findPath();</span><br><span class="line"></span><br><span class="line">    draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When mouse is clicked</span></span><br><span class="line"><span class="built_in">window</span>.onclick = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When mouse is moved</span></span><br><span class="line"><span class="built_in">window</span>.onmousemove = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you run it, you should see the following.</p>
<p><img src="/images/12/image9.png" style="width:75%"></p>
<h5 id="Adding-obstacles"><a href="#Adding-obstacles" class="headerlink" title="Adding obstacles"></a>Adding obstacles</h5><p>For obstacles, we’re just going to add some walls. This should be quite simple.<br>First we need property on node class to indicate if it’s a wall or not.</p>
<p>Add <em>isWall</em> property to <em>Node</em> class constructor.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">      <span class="comment">// other properties ...</span></span><br><span class="line">      <span class="keyword">this</span>.isWall = <span class="built_in">Math</span>.random() &gt; <span class="number">0.9</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p> <em>Math.random() &gt; 0.9</em> will give small chance to a Node to be a wall. Random returns random value between 0 and 1, so there is 10% chance that node is a wall.</p>
<p>In <em>draw</em> method, withing existing double <em>for</em> loop, set node color to white.If node is a wall node it should be black.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; cols; x++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; rows; y++) &#123;</span><br><span class="line">          nodes[x][y].draw();</span><br><span class="line">          nodes[x][y].color = <span class="string">"white"</span>;</span><br><span class="line">          <span class="keyword">if</span>(nodes[x][y].isWall)&#123;</span><br><span class="line">              nodes[x][y].color = <span class="string">"black"</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>And finally add wall checks to <em>getNeighbourNodes</em>.<br>This will make sure that node walls are not added to neighbours, and therefore can’t be analyed or moved to.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; !nodes[x<span class="number">-1</span>][y].isWall) &#123;</span><br><span class="line">    neighbourNodes.push(nodes[x - <span class="number">1</span>][y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x &lt; cols - <span class="number">1</span> &amp;&amp; !nodes[x+<span class="number">1</span>][y].isWall) &#123;</span><br><span class="line">    neighbourNodes.push(nodes[x + <span class="number">1</span>][y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (y &gt; <span class="number">0</span> &amp;&amp; !nodes[x][y - <span class="number">1</span>].isWall) &#123;</span><br><span class="line">    neighbourNodes.push(nodes[x][y - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (y &lt; rows - <span class="number">1</span> &amp;&amp; !nodes[x][y + <span class="number">1</span>].isWall) &#123;</span><br><span class="line">    neighbourNodes.push(nodes[x][y + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Running the code should result in this.</p>
<p><img src="/images/12/image10.png" style="width:75%"></p>
<p>All code so far </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Globals</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="literal">null</span>,</span><br><span class="line">    ctx = <span class="literal">null</span>,</span><br><span class="line">    nodeWidth = <span class="literal">null</span>,</span><br><span class="line">    nodeHeight = <span class="literal">null</span>,</span><br><span class="line">    nodes = [],</span><br><span class="line">    rows = <span class="number">30</span>,</span><br><span class="line">    cols = <span class="number">40</span>,</span><br><span class="line">    path = [],</span><br><span class="line">    startNode = <span class="literal">null</span>,</span><br><span class="line">    endNode = <span class="literal">null</span>,</span><br><span class="line">    moveCost = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.gridX = x;</span><br><span class="line">        <span class="keyword">this</span>.gridY = y;</span><br><span class="line">        <span class="keyword">this</span>.color = <span class="string">"white"</span>;</span><br><span class="line">        <span class="keyword">this</span>.parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.g = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.isWall = <span class="built_in">Math</span>.random() &gt; <span class="number">0.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    draw() &#123;</span><br><span class="line">        ctx.fillStyle = <span class="keyword">this</span>.color;</span><br><span class="line">        ctx.fillRect(<span class="keyword">this</span>.gridX * nodeWidth, <span class="keyword">this</span>.gridY * nodeHeight, nodeWidth - <span class="number">1</span>, nodeHeight - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Draws to screen</span></span><br><span class="line"><span class="keyword">const</span> draw = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    ctx.fillStyle = <span class="string">"black"</span>;</span><br><span class="line">    ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; cols; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; rows; y++) &#123;</span><br><span class="line">            nodes[x][y].draw();</span><br><span class="line">            nodes[x][y].color = <span class="string">"white"</span>;</span><br><span class="line">            <span class="keyword">if</span>(nodes[x][y].isWall)&#123;</span><br><span class="line">                nodes[x][y].color = <span class="string">"black"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _.forEach(path, node =&gt; &#123;</span><br><span class="line">        node.color = <span class="string">"green"</span>;</span><br><span class="line">        node.draw();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render loop</span></span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> heuristic = <span class="function">(<span class="params">nodeA, nodeB</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dx = <span class="built_in">Math</span>.abs(nodeA.gridX - nodeB.gridX);</span><br><span class="line">    <span class="keyword">const</span> dy = <span class="built_in">Math</span>.abs(nodeA.gridY - nodeB.gridY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dx + dy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> findPath = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> closedSet = [];</span><br><span class="line">    <span class="keyword">const</span> openSet = [startNode];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (openSet.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentNode = _.minBy(openSet, x =&gt; x.f);</span><br><span class="line"></span><br><span class="line">        _.remove(openSet, currentNode);</span><br><span class="line">        closedSet.push(currentNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> neighbourNodes = getNeighbourNodes(currentNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; neighbourNodes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> neighbourNode = neighbourNodes[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_.includes(closedSet, neighbourNode)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            neighbourNode.g = currentNode.g + moveCost;</span><br><span class="line">            neighbourNode.h = heuristic(neighbourNode, endNode);</span><br><span class="line">            neighbourNode.f = neighbourNode.g + neighbourNode.h;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> index = _.indexOf(openSet, neighbourNode);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                openSet.push(neighbourNode);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (neighbourNode.g &gt;= openSet[index].g) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            neighbourNode.parent = currentNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentNode === endNode) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> endPath = [currentNode];</span><br><span class="line">            <span class="keyword">while</span> (currentNode.parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">                currentNode = currentNode.parent;</span><br><span class="line">                endPath.push(currentNode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> endPath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getNeighbourNodes = <span class="function"><span class="params">currentNode</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> neighbourNodes = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> x = currentNode.gridX,</span><br><span class="line">        y = currentNode.gridY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; !nodes[x<span class="number">-1</span>][y].isWall) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x - <span class="number">1</span>][y]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; cols - <span class="number">1</span> &amp;&amp; !nodes[x+<span class="number">1</span>][y].isWall) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x + <span class="number">1</span>][y]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y &gt; <span class="number">0</span> &amp;&amp; !nodes[x][y - <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x][y - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y &lt; rows - <span class="number">1</span> &amp;&amp; !nodes[x][y + <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x][y + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> neighbourNodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// On browser load</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    canvas = <span class="built_in">document</span>.getElementById(<span class="string">"render-canvas"</span>);</span><br><span class="line">    ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">    nodeWidth = canvas.width / cols;</span><br><span class="line">    nodeHeight = canvas.height / rows;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; cols; x++) &#123;</span><br><span class="line">        nodes[x] = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; rows; y++) &#123;</span><br><span class="line">            nodes[x][y] = <span class="keyword">new</span> Node(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startNode = nodes[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    endNode = nodes[cols - <span class="number">1</span>][rows - <span class="number">1</span>];</span><br><span class="line">    path = findPath();</span><br><span class="line"></span><br><span class="line">    draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When mouse is clicked</span></span><br><span class="line"><span class="built_in">window</span>.onclick = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When mouse is moved</span></span><br><span class="line"><span class="built_in">window</span>.onmousemove = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Diagonal-movement"><a href="#Diagonal-movement" class="headerlink" title="Diagonal movement"></a>Diagonal movement</h5><p>Finally we’re adding diagonal movement. So far nodes could be traversed up, down, left and right and cost of that movement was 10. Let’s add diagonal movement, but with cost of 15, since it’s actually bigger step to move diagonally, so it makes sense.</p>
<p>Right after move cost add </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    moveCost = <span class="number">10</span>,</span><br><span class="line">    diagonalMoveCost = <span class="number">15</span>;</span><br></pre></td></tr></table></figure>
<p>Next we should actually apply that diagonal move cost.</p>
<p>Change code where <em>neighbourNode.g</em> is set, to following.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">neighbourNode.g = currentNode.g + (neighbourNode.isDiagonalMove ? diagonalMoveCost : moveCost);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>And change <em>neighbourNodes</em> function to</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getNeighbourNodes = <span class="function"><span class="params">currentNode</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> neighbourNodes = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> x = currentNode.gridX,</span><br><span class="line">        y = currentNode.gridY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> downLeft = <span class="literal">true</span>,</span><br><span class="line">        upLeft = <span class="literal">true</span>,</span><br><span class="line">        downRight = <span class="literal">true</span>,</span><br><span class="line">        upRight = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; !nodes[x - <span class="number">1</span>][y].isWall) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x - <span class="number">1</span>][y]);</span><br><span class="line">        nodes[x - <span class="number">1</span>][y].isDiagonalMove = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        downLeft = <span class="literal">false</span>;</span><br><span class="line">        upLeft = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; cols - <span class="number">1</span> &amp;&amp; !nodes[x + <span class="number">1</span>][y].isWall) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x + <span class="number">1</span>][y]);</span><br><span class="line">        nodes[x+<span class="number">1</span>][y].isDiagonalMove = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        downRight = <span class="literal">false</span>;</span><br><span class="line">        upRight = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y &gt; <span class="number">0</span> &amp;&amp; !nodes[x][y - <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x][y - <span class="number">1</span>]);</span><br><span class="line">        nodes[x][y - <span class="number">1</span>].isDiagonalMove = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        upLeft = <span class="literal">false</span>;</span><br><span class="line">        upRight = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y &lt; rows - <span class="number">1</span> &amp;&amp; !nodes[x][y + <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x][y + <span class="number">1</span>]);</span><br><span class="line">        nodes[x][y + <span class="number">1</span>].isDiagonalMove = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        downLeft = <span class="literal">false</span>;</span><br><span class="line">        downRight = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (upRight &amp;&amp; !nodes[x + <span class="number">1</span>][y - <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        nodes[x + <span class="number">1</span>][y - <span class="number">1</span>].isDiagonalMove = <span class="literal">true</span>;</span><br><span class="line">        neighbourNodes.push(nodes[x + <span class="number">1</span>][y - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (upLeft &amp;&amp; !nodes[x - <span class="number">1</span>][y - <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        nodes[x - <span class="number">1</span>][y - <span class="number">1</span>].isDiagonalMove = <span class="literal">true</span>;</span><br><span class="line">        neighbourNodes.push(nodes[x - <span class="number">1</span>][y - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (downRight &amp;&amp; !nodes[x + <span class="number">1</span>][y + <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        nodes[x + <span class="number">1</span>][y + <span class="number">1</span>].isDiagonalMove = <span class="literal">true</span>;</span><br><span class="line">        neighbourNodes.push(nodes[x + <span class="number">1</span>][y + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (downLeft &amp;&amp; !nodes[x - <span class="number">1</span>][y + <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        nodes[x - <span class="number">1</span>][y + <span class="number">1</span>].isDiagonalMove = <span class="literal">true</span>;</span><br><span class="line">        neighbourNodes.push(nodes[x - <span class="number">1</span>][y + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> neighbourNodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You might find this part with <em>downLeft</em> and other direction bit confusing, but it’s just a simple check. If for example there is move to one unit right, but that node is a wall, this code also disables up right move and right down move. Same is true for other directions. </p>
<p>Also change heuristic model to use Euclidian distance, since there are now diagonal moves.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> heuristic = <span class="function">(<span class="params">nodeA, nodeB</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dx = nodeA.gridX - nodeB.gridX;</span><br><span class="line">    <span class="keyword">const</span> dy = nodeA.gridY - nodeB.gridY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(dx * dx + dy * dy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Run the code.</p>
<p><img src="/images/12/image11.png" style="width:75%"></p>
<p>All code so far.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Globals</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="literal">null</span>,</span><br><span class="line">    ctx = <span class="literal">null</span>,</span><br><span class="line">    nodeWidth = <span class="literal">null</span>,</span><br><span class="line">    nodeHeight = <span class="literal">null</span>,</span><br><span class="line">    nodes = [],</span><br><span class="line">    rows = <span class="number">30</span>,</span><br><span class="line">    cols = <span class="number">40</span>,</span><br><span class="line">    path = [],</span><br><span class="line">    startNode = <span class="literal">null</span>,</span><br><span class="line">    endNode = <span class="literal">null</span>,</span><br><span class="line">    moveCost = <span class="number">10</span>,</span><br><span class="line">    diagonalMoveCost = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.gridX = x;</span><br><span class="line">        <span class="keyword">this</span>.gridY = y;</span><br><span class="line">        <span class="keyword">this</span>.color = <span class="string">"white"</span>;</span><br><span class="line">        <span class="keyword">this</span>.parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.g = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.isWall = <span class="built_in">Math</span>.random() &gt; <span class="number">0.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    draw() &#123;</span><br><span class="line">        ctx.fillStyle = <span class="keyword">this</span>.color;</span><br><span class="line">        ctx.fillRect(<span class="keyword">this</span>.gridX * nodeWidth, <span class="keyword">this</span>.gridY * nodeHeight, nodeWidth - <span class="number">1</span>, nodeHeight - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Draws to screen</span></span><br><span class="line"><span class="keyword">const</span> draw = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    ctx.fillStyle = <span class="string">"black"</span>;</span><br><span class="line">    ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; cols; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; rows; y++) &#123;</span><br><span class="line">            nodes[x][y].draw();</span><br><span class="line">            nodes[x][y].color = <span class="string">"white"</span>;</span><br><span class="line">            <span class="keyword">if</span>(nodes[x][y].isWall)&#123;</span><br><span class="line">                nodes[x][y].color = <span class="string">"black"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _.forEach(path, node =&gt; &#123;</span><br><span class="line">        node.color = <span class="string">"green"</span>;</span><br><span class="line">        node.draw();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render loop</span></span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> heuristic = <span class="function">(<span class="params">nodeA, nodeB</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dx = nodeA.gridX - nodeB.gridX;</span><br><span class="line">    <span class="keyword">const</span> dy = nodeA.gridY - nodeB.gridY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(dx * dx + dy * dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> findPath = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> closedSet = [];</span><br><span class="line">    <span class="keyword">const</span> openSet = [startNode];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (openSet.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentNode = _.minBy(openSet, x =&gt; x.f);</span><br><span class="line"></span><br><span class="line">        _.remove(openSet, currentNode);</span><br><span class="line">        closedSet.push(currentNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> neighbourNodes = getNeighbourNodes(currentNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; neighbourNodes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> neighbourNode = neighbourNodes[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_.includes(closedSet, neighbourNode)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            neighbourNode.g = currentNode.g + (neighbourNode.isDiagonalMove ? diagonalMoveCost : moveCost);</span><br><span class="line">            neighbourNode.h = heuristic(neighbourNode, endNode);</span><br><span class="line">            neighbourNode.f = neighbourNode.g + neighbourNode.h;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> index = _.indexOf(openSet, neighbourNode);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                openSet.push(neighbourNode);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (neighbourNode.g &gt;= openSet[index].g) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            neighbourNode.parent = currentNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentNode === endNode) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> endPath = [currentNode];</span><br><span class="line">            <span class="keyword">while</span> (currentNode.parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">                currentNode = currentNode.parent;</span><br><span class="line">                endPath.push(currentNode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> endPath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getNeighbourNodes = <span class="function"><span class="params">currentNode</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> neighbourNodes = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> x = currentNode.gridX,</span><br><span class="line">        y = currentNode.gridY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> downLeft = <span class="literal">true</span>,</span><br><span class="line">        upLeft = <span class="literal">true</span>,</span><br><span class="line">        downRight = <span class="literal">true</span>,</span><br><span class="line">        upRight = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; !nodes[x - <span class="number">1</span>][y].isWall) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x - <span class="number">1</span>][y]);</span><br><span class="line">        nodes[x - <span class="number">1</span>][y].isDiagonalMove = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        downLeft = <span class="literal">false</span>;</span><br><span class="line">        upLeft = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; cols - <span class="number">1</span> &amp;&amp; !nodes[x + <span class="number">1</span>][y].isWall) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x + <span class="number">1</span>][y]);</span><br><span class="line">        nodes[x+<span class="number">1</span>][y].isDiagonalMove = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        downRight = <span class="literal">false</span>;</span><br><span class="line">        upRight = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y &gt; <span class="number">0</span> &amp;&amp; !nodes[x][y - <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x][y - <span class="number">1</span>]);</span><br><span class="line">        nodes[x][y - <span class="number">1</span>].isDiagonalMove = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        upLeft = <span class="literal">false</span>;</span><br><span class="line">        upRight = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y &lt; rows - <span class="number">1</span> &amp;&amp; !nodes[x][y + <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x][y + <span class="number">1</span>]);</span><br><span class="line">        nodes[x][y + <span class="number">1</span>].isDiagonalMove = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        downLeft = <span class="literal">false</span>;</span><br><span class="line">        downRight = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (upRight &amp;&amp; !nodes[x + <span class="number">1</span>][y - <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        nodes[x + <span class="number">1</span>][y - <span class="number">1</span>].isDiagonalMove = <span class="literal">true</span>;</span><br><span class="line">        neighbourNodes.push(nodes[x + <span class="number">1</span>][y - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (upLeft &amp;&amp; !nodes[x - <span class="number">1</span>][y - <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        nodes[x - <span class="number">1</span>][y - <span class="number">1</span>].isDiagonalMove = <span class="literal">true</span>;</span><br><span class="line">        neighbourNodes.push(nodes[x - <span class="number">1</span>][y - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (downRight &amp;&amp; !nodes[x + <span class="number">1</span>][y + <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        nodes[x + <span class="number">1</span>][y + <span class="number">1</span>].isDiagonalMove = <span class="literal">true</span>;</span><br><span class="line">        neighbourNodes.push(nodes[x + <span class="number">1</span>][y + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (downLeft &amp;&amp; !nodes[x - <span class="number">1</span>][y + <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        nodes[x - <span class="number">1</span>][y + <span class="number">1</span>].isDiagonalMove = <span class="literal">true</span>;</span><br><span class="line">        neighbourNodes.push(nodes[x - <span class="number">1</span>][y + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> neighbourNodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// On browser load</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    canvas = <span class="built_in">document</span>.getElementById(<span class="string">"render-canvas"</span>);</span><br><span class="line">    ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">    nodeWidth = canvas.width / cols;</span><br><span class="line">    nodeHeight = canvas.height / rows;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; cols; x++) &#123;</span><br><span class="line">        nodes[x] = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; rows; y++) &#123;</span><br><span class="line">            nodes[x][y] = <span class="keyword">new</span> Node(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startNode = nodes[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    endNode = nodes[cols - <span class="number">1</span>][rows - <span class="number">1</span>];</span><br><span class="line">    path = findPath();</span><br><span class="line"></span><br><span class="line">    draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When mouse is clicked</span></span><br><span class="line"><span class="built_in">window</span>.onclick = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When mouse is moved</span></span><br><span class="line"><span class="built_in">window</span>.onmousemove = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Mouse-events"><a href="#Mouse-events" class="headerlink" title="Mouse events"></a>Mouse events</h5><p>Well example wouldn’t be complete without some interactivity. Let’s implement those mouse events.<br>Add following to <em>onclick</em> event call.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onclick = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isSearching) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> x = event.pageX - canvas.offsetLeft;</span><br><span class="line">    <span class="keyword">const</span> y = event.pageY - canvas.offsetTop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> gridX = <span class="built_in">parseInt</span>(x / nodeWidth);</span><br><span class="line">    <span class="keyword">const</span> gridY = <span class="built_in">parseInt</span>(y / nodeHeight);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nodes[gridX]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes[gridX][gridY] &amp;&amp; !nodes[gridX][gridY].isWall &amp;&amp; startNode !== nodes[gridX][gridY]) &#123;</span><br><span class="line">            startNode = nodes[gridX][gridY];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>First <em>isSearching</em> just checks if algorithm is already in search, if so do nothing.</p>
<p><em>X</em> and <em>y</em> are simply positions of mouse click on canvas element, corrected by canvas offset. <em>GridX</em> and <em>gridY</em> values are indexes of node. Dividing positions by width and height, plus parsing to integer value, does that trick for finding actual <em>gridX</em> and <em>gridY</em> indexes.</p>
<p>Rest of code simply checks if actual node exists on that position and makes sure that node is not a wall. If so it’s added as new start node. </p>
<p>Next is <em>onmousemove</em> which is excatly the same, except that it sets <em>endNode</em> and calls <em>findPath</em>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// When mouse is moved</span></span><br><span class="line"><span class="built_in">window</span>.onmousemove = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isSearching) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> x = event.pageX - canvas.offsetLeft;</span><br><span class="line">    <span class="keyword">const</span> y = event.pageY - canvas.offsetTop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> gridX = <span class="built_in">parseInt</span>(x / nodeWidth);</span><br><span class="line">    <span class="keyword">const</span> gridY = <span class="built_in">parseInt</span>(y / nodeHeight);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nodes[gridX]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes[gridX][gridY] &amp;&amp; !nodes[gridX][gridY].isWall &amp;&amp; endNode !== nodes[gridX][gridY]) &#123;</span><br><span class="line">            endNode = nodes[gridX][gridY];</span><br><span class="line">            path = findPath();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time to add <em>isSearching</em> global variable. Add it right after <em>diagonalMoveCost</em> definition.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">diagonalMoveCost = <span class="number">15</span>,</span><br><span class="line">isSearching = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>One last change is to <em>findPath</em>. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findPath = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// notice double for loop</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; cols;x++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> y = <span class="number">0</span>; y &lt; rows; y++)&#123;</span><br><span class="line">            nodes[x][y].parent = <span class="literal">null</span>;</span><br><span class="line">            nodes[x][y].isDiagonalMove = <span class="literal">false</span>;</span><br><span class="line">            nodes[x][y].g = <span class="number">0</span>;</span><br><span class="line">            nodes[x][y].h = <span class="number">0</span>;</span><br><span class="line">            nodes[x][y].f = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> closedSet = [];</span><br><span class="line">    <span class="keyword">const</span> openSet = [startNode];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set is searching.</span></span><br><span class="line">    isSearching = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (openSet.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentNode = _.minBy(openSet, x =&gt; x.f);</span><br><span class="line"></span><br><span class="line">        _.remove(openSet, currentNode);</span><br><span class="line">        closedSet.push(currentNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> neighbourNodes = getNeighbourNodes(currentNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; neighbourNodes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> neighbourNode = neighbourNodes[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_.includes(closedSet, neighbourNode)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            neighbourNode.g = currentNode.g + (neighbourNode.isDiagonalMove ? diagonalMoveCost : moveCost);</span><br><span class="line">            neighbourNode.h = heuristic(neighbourNode, endNode);</span><br><span class="line">            neighbourNode.f = neighbourNode.g + neighbourNode.h;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> index = _.indexOf(openSet, neighbourNode);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                openSet.push(neighbourNode);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (neighbourNode.g &gt;= openSet[index].g) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            neighbourNode.parent = currentNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentNode === endNode) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> endPath = [currentNode];</span><br><span class="line">            <span class="keyword">while</span> (currentNode.parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">                currentNode = currentNode.parent;</span><br><span class="line">                endPath.push(currentNode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// set is searching to false</span></span><br><span class="line">            isSearching = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> endPath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set is searching to false</span></span><br><span class="line">    isSearching = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Two things to notice here, first is double <em>for</em> loop which clears the parent, all costs and diagonal moves for all nodes. Not clearing properties will lead to errors, since values were set in previous <em>draw</em> calls. Other things to notice are 3 <em>isSearching</em> sets. This is just for optimization, since algorithm might take some time, and our <em>onmousemove</em> might call <em>findPath</em> before path is actually found, which might lead to browser crashes :)</p>
<p>Final code looks like this.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Globals</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="literal">null</span>,</span><br><span class="line">    ctx = <span class="literal">null</span>,</span><br><span class="line">    nodeWidth = <span class="literal">null</span>,</span><br><span class="line">    nodeHeight = <span class="literal">null</span>,</span><br><span class="line">    nodes = [],</span><br><span class="line">    rows = <span class="number">30</span>,</span><br><span class="line">    cols = <span class="number">40</span>,</span><br><span class="line">    path = [],</span><br><span class="line">    startNode = <span class="literal">null</span>,</span><br><span class="line">    endNode = <span class="literal">null</span>,</span><br><span class="line">    moveCost = <span class="number">10</span>,</span><br><span class="line">    diagonalMoveCost = <span class="number">15</span>,</span><br><span class="line">    isSearching = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.gridX = x;</span><br><span class="line">        <span class="keyword">this</span>.gridY = y;</span><br><span class="line">        <span class="keyword">this</span>.color = <span class="string">"white"</span>;</span><br><span class="line">        <span class="keyword">this</span>.parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.g = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.isWall = <span class="built_in">Math</span>.random() &gt; <span class="number">0.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    draw() &#123;</span><br><span class="line">        ctx.fillStyle = <span class="keyword">this</span>.color;</span><br><span class="line">        ctx.fillRect(<span class="keyword">this</span>.gridX * nodeWidth, <span class="keyword">this</span>.gridY * nodeHeight, nodeWidth - <span class="number">1</span>, nodeHeight - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Draws to screen</span></span><br><span class="line"><span class="keyword">const</span> draw = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    ctx.fillStyle = <span class="string">"black"</span>;</span><br><span class="line">    ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; cols; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; rows; y++) &#123;</span><br><span class="line">            nodes[x][y].draw();</span><br><span class="line">            nodes[x][y].color = <span class="string">"white"</span>;</span><br><span class="line">            <span class="keyword">if</span>(nodes[x][y].isWall)&#123;</span><br><span class="line">                nodes[x][y].color = <span class="string">"black"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _.forEach(path, node =&gt; &#123;</span><br><span class="line">        node.color = <span class="string">"green"</span>;</span><br><span class="line">        node.draw();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render loop</span></span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> heuristic = <span class="function">(<span class="params">nodeA, nodeB</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dx = nodeA.gridX - nodeB.gridX;</span><br><span class="line">    <span class="keyword">const</span> dy = nodeA.gridY - nodeB.gridY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(dx * dx + dy * dy) * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> findPath = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; cols;x++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> y = <span class="number">0</span>; y &lt; rows; y++)&#123;</span><br><span class="line">            nodes[x][y].parent = <span class="literal">null</span>;</span><br><span class="line">            nodes[x][y].isDiagonalMove = <span class="literal">false</span>;</span><br><span class="line">            nodes[x][y].g = <span class="number">0</span>;</span><br><span class="line">            nodes[x][y].h = <span class="number">0</span>;</span><br><span class="line">            nodes[x][y].f = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> closedSet = [];</span><br><span class="line">    <span class="keyword">const</span> openSet = [startNode];</span><br><span class="line"></span><br><span class="line">    isSearching = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (openSet.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentNode = _.minBy(openSet, x =&gt; x.f);</span><br><span class="line"></span><br><span class="line">        _.remove(openSet, currentNode);</span><br><span class="line">        closedSet.push(currentNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> neighbourNodes = getNeighbourNodes(currentNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; neighbourNodes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> neighbourNode = neighbourNodes[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_.includes(closedSet, neighbourNode)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            neighbourNode.g = currentNode.g + (neighbourNode.isDiagonalMove ? diagonalMoveCost : moveCost);</span><br><span class="line">            neighbourNode.h = heuristic(neighbourNode, endNode);</span><br><span class="line">            neighbourNode.f = neighbourNode.g + neighbourNode.h;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> index = _.indexOf(openSet, neighbourNode);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                openSet.push(neighbourNode);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (neighbourNode.g &gt;= openSet[index].g) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            neighbourNode.parent = currentNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentNode === endNode) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> endPath = [currentNode];</span><br><span class="line">            <span class="keyword">while</span> (currentNode.parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">                currentNode = currentNode.parent;</span><br><span class="line">                endPath.push(currentNode);</span><br><span class="line">            &#125;</span><br><span class="line">            isSearching = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> endPath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    isSearching = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getNeighbourNodes = <span class="function"><span class="params">currentNode</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> neighbourNodes = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> x = currentNode.gridX,</span><br><span class="line">        y = currentNode.gridY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> downLeft = <span class="literal">true</span>,</span><br><span class="line">        upLeft = <span class="literal">true</span>,</span><br><span class="line">        downRight = <span class="literal">true</span>,</span><br><span class="line">        upRight = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; !nodes[x - <span class="number">1</span>][y].isWall) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x - <span class="number">1</span>][y]);</span><br><span class="line">        nodes[x - <span class="number">1</span>][y].isDiagonalMove = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        downLeft = <span class="literal">false</span>;</span><br><span class="line">        upLeft = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; cols - <span class="number">1</span> &amp;&amp; !nodes[x + <span class="number">1</span>][y].isWall) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x + <span class="number">1</span>][y]);</span><br><span class="line">        nodes[x + <span class="number">1</span>][y].isDiagonalMove = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        downRight = <span class="literal">false</span>;</span><br><span class="line">        upRight = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y &gt; <span class="number">0</span> &amp;&amp; !nodes[x][y - <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x][y - <span class="number">1</span>]);</span><br><span class="line">        nodes[x][y - <span class="number">1</span>].isDiagonalMove = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        upLeft = <span class="literal">false</span>;</span><br><span class="line">        upRight = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y &lt; rows - <span class="number">1</span> &amp;&amp; !nodes[x][y + <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        neighbourNodes.push(nodes[x][y + <span class="number">1</span>]);</span><br><span class="line">        nodes[x][y + <span class="number">1</span>].isDiagonalMove = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        downLeft = <span class="literal">false</span>;</span><br><span class="line">        downRight = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (upRight &amp;&amp; !nodes[x + <span class="number">1</span>][y - <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        nodes[x + <span class="number">1</span>][y - <span class="number">1</span>].diagonalMove = <span class="literal">true</span>;</span><br><span class="line">        neighbourNodes.push(nodes[x + <span class="number">1</span>][y - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (upLeft &amp;&amp; !nodes[x - <span class="number">1</span>][y - <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        nodes[x - <span class="number">1</span>][y - <span class="number">1</span>].diagonalMove = <span class="literal">true</span>;</span><br><span class="line">        neighbourNodes.push(nodes[x - <span class="number">1</span>][y - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (downRight &amp;&amp; !nodes[x + <span class="number">1</span>][y + <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        nodes[x + <span class="number">1</span>][y + <span class="number">1</span>].diagonalMove = <span class="literal">true</span>;</span><br><span class="line">        neighbourNodes.push(nodes[x + <span class="number">1</span>][y + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (downLeft &amp;&amp; !nodes[x - <span class="number">1</span>][y + <span class="number">1</span>].isWall) &#123;</span><br><span class="line">        nodes[x - <span class="number">1</span>][y + <span class="number">1</span>].diagonalMove = <span class="literal">true</span>;</span><br><span class="line">        neighbourNodes.push(nodes[x - <span class="number">1</span>][y + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> neighbourNodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// On browser load</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    canvas = <span class="built_in">document</span>.getElementById(<span class="string">"render-canvas"</span>);</span><br><span class="line">    ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">    nodeWidth = canvas.width / cols;</span><br><span class="line">    nodeHeight = canvas.height / rows;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; cols; x++) &#123;</span><br><span class="line">        nodes[x] = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; rows; y++) &#123;</span><br><span class="line">            nodes[x][y] = <span class="keyword">new</span> Node(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startNode = nodes[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    endNode = nodes[cols - <span class="number">1</span>][rows - <span class="number">1</span>];</span><br><span class="line">    path = findPath();</span><br><span class="line"></span><br><span class="line">    draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When mouse is clicked</span></span><br><span class="line"><span class="built_in">window</span>.onclick = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isSearching) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> x = event.pageX - canvas.offsetLeft;</span><br><span class="line">    <span class="keyword">const</span> y = event.pageY - canvas.offsetTop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> gridX = <span class="built_in">parseInt</span>(x / nodeWidth);</span><br><span class="line">    <span class="keyword">const</span> gridY = <span class="built_in">parseInt</span>(y / nodeHeight);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nodes[gridX]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes[gridX][gridY] &amp;&amp; !nodes[gridX][gridY].isWall &amp;&amp; startNode !== nodes[gridX][gridY]) &#123;</span><br><span class="line">            startNode = nodes[gridX][gridY];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When mouse is moved</span></span><br><span class="line"><span class="built_in">window</span>.onmousemove = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isSearching) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> x = event.pageX - canvas.offsetLeft;</span><br><span class="line">    <span class="keyword">const</span> y = event.pageY - canvas.offsetTop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> gridX = <span class="built_in">parseInt</span>(x / nodeWidth);</span><br><span class="line">    <span class="keyword">const</span> gridY = <span class="built_in">parseInt</span>(y / nodeHeight);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nodes[gridX]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes[gridX][gridY] &amp;&amp; !nodes[gridX][gridY].isWall &amp;&amp; endNode !== nodes[gridX][gridY]) &#123;</span><br><span class="line">            endNode = nodes[gridX][gridY];</span><br><span class="line">            path = findPath();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And this is what you should have now.</p>

<button id="path-finding-reset-8">Reset</button>
<br>
<br>
<canvas id="path-finding-canvas-8" width="800" height="600"></canvas>
<script>
"use strict";var _createClass=function(){function i(i,e){for(var n=0;n<e.length;n++){var l=e[n];l.enumerable=l.enumerable||!1,l.configurable=!0,"value"in l&&(l.writable=!0),Object.defineProperty(i,l.key,l)}}return function(e,n,l){return n&&i(e.prototype,n),l&&i(e,l),e}}();function _classCallCheck(i,e){if(!(i instanceof e))throw new TypeError("Cannot call a class as a function")}var example8Module=function(i){var e=null,n=[],l=void 0,r=void 0,a=[],o=[],t=[],s=void 0,f=void 0,u=!1,c=30,g=40,d=function(){function i(e,n){_classCallCheck(this,i),this.gridX=e,this.gridY=n,this.color="white",this.parent=null,this.f=0,this.g=0,this.h=0,this.isWall=Math.random()>.9}return _createClass(i,[{key:"draw",value:function(i){i.fillStyle=this.color,i.fillRect(this.gridX*s,this.gridY*f,s-1,f-1)}}]),i}(),v=function(){for(var i=0;i<g;i++)for(var e=0;e<c;e++)n[i][e].parent=null;for(u=!0,t=[],o=[l];o.length>0;){var a=_.minBy(o,function(i){return i.f});if(a.gridX===r.gridX&&a.gridY===r.gridY){for(var s=a,f=[s];null!==s.parent;)s=s.parent,f.push(s);return u=!1,f}_.remove(o,a),t.push(a);for(var d=(X=void 0,void 0,void 0,D=void 0,b=void 0,C=void 0,T=void 0,X=[],Y=(w=a).gridX,k=w.gridY,D=!0,b=!0,C=!0,T=!0,w.gridX>0&&!n[Y-1][k].isWall?(X.push(n[Y-1][k]),n[Y-1][k].isDiagonalMove=!1):(D=!1,b=!1),w.gridX<39&&!n[Y+1][k].isWall?(X.push(n[Y+1][k]),n[Y+1][k].isDiagonalMove=!1):(C=!1,T=!1),w.gridY>0&&!n[Y][k-1].isWall?(X.push(n[Y][k-1]),n[Y][k-1].isDiagonalMove=!1):(b=!1,T=!1),w.gridY<29&&!n[Y][k+1].isWall?(X.push(n[Y][k+1]),n[Y][k+1].isDiagonalMove=!1):(D=!1,C=!1),T&&!n[Y+1][k-1].isWall&&(X.push(n[Y+1][k-1]),n[Y+1][k-1].isDiagonalMove=!0),b&&!n[Y-1][k-1].isWall&&(X.push(n[Y-1][k-1]),n[Y-1][k-1].isDiagonalMove=!0),C&&!n[Y+1][k+1].isWall&&(X.push(n[Y+1][k+1]),n[Y+1][k+1].isDiagonalMove=!0),D&&!n[Y-1][k+1].isWall&&(X.push(n[Y-1][k+1]),n[Y-1][k+1].isDiagonalMove=!0),X),v=0;v<d.length;v++){var h=d[v];if(!_.includes(t,h)){h.g=a.g+(h.isDiagonalMove?1.5:1),h.h=(W=r,void 0,void 0,y=(m=h).gridX-W.gridX,M=m.gridY-W.gridY,Math.sqrt(y*y+M*M)),h.f=h.g+h.h;var p=_.indexOf(o,h);if(p<0)o.push(h);else if(h.g>=o[p].g)continue;h.parent=a}}}var m,W,y,M,w,X,Y,k,D,b,C,T;return u=!1,[]},h=function(){var u=e.getContext("2d");s=e.width/g,f=e.height/c,n=[],l=null,r=null;for(var h=0;h<g;h++){n[h]=[];for(var p=0;p<c;p++)n[h][p]=new d(h,p),n[h][p].isWall||l||(l=n[h][p])}for(h=39;h>=0;h--){for(p=29;p>=0&&((r=n[h][p]).isWall&&(r=null),null==r);p--);if(null!=r)break}o=[l],t=[];a=v(),function l(){u.fillStyle="black",u.fillRect(0,0,e.width,e.height);for(var r=0;r<g;r++)for(var o=0;o<c;o++){var t=n[r][o];t.color="white",t.isWall&&(t.color="black"),t.draw(u)}_.forEach(a,function(i){i.color="green",i.draw(u)}),i.requestAnimationFrame(l)}()};return{onload:function(){e=i.document.getElementById("path-finding-canvas-8"),i.document.getElementById("path-finding-reset-8").onclick=function(){h()},h()},onclick:function(r){if(!u){var a=i.document.getElementsByTagName("main")[0],o=r.pageX-e.offsetLeft+a.scrollLeft,t=r.pageY-e.offsetTop+a.scrollTop,c=parseInt(o/s),g=parseInt(t/f);n[c]&&n[c][g]&&!n[c][g].isWall&&l!==n[c][g]&&(l=n[c][g])}},onmousemove:function(l){if(!u){var o=i.document.getElementsByTagName("main")[0],t=l.pageX-e.offsetLeft+o.scrollLeft,c=l.pageY-e.offsetTop+o.scrollTop,g=parseInt(t/s),d=parseInt(c/f);n[g]&&n[g][d]&&!n[g][d].isWall&&r!==n[g][d]&&(r=n[g][d],a=v())}}}};
</script>


<script>
var module1 = example1Module(window);
var module2 = example2Module(window);
var module3 = example3Module(window);
var module4 = example4Module(window);
var module5 = example5Module(window);
var module6 = example6Module(window);
var module7 = example7Module(window);
var module8 = example8Module(window);
module1.onload();
module2.onload();
module3.onload();
module4.onload();
module5.onload();
module6.onload();
module7.onload();
module8.onload();
document.getElementById("path-finding-canvas").onclick = function(e){
    module1.onclick(event);
}
document.getElementById("path-finding-canvas-2").onclick = function(e){
    module2.onclick(event);
}
document.getElementById("path-finding-canvas-3").onclick = function(e){
    module3.onclick(event);
}
document.getElementById("path-finding-canvas-4").onclick = function(e){
    module4.onclick(event);
}
document.getElementById("path-finding-canvas-5").onclick = function(e){
    module5.onclick(event);
}
document.getElementById("path-finding-canvas-6").onclick = function(e){
    module6.onclick(event);
}
document.getElementById("path-finding-canvas-7").onclick = function(e){
    module7.onclick(event);
}
document.getElementById("path-finding-canvas-8").onclick = function(e){
    module8.onclick(event);
}
window.onmousemove = function(event){
    module1.onmousemove(event);
    module2.onmousemove(event);
    module3.onmousemove(event);
    module8.onmousemove(event);
}
</script>


<p><br></p>
<p>I have added code sample to <a href="https://codepen.io/luka712/pen/VgvyNN" target="_blank" rel="noopener">codepen</a>.<br>And as always, code is on <a href="https://github.com/luka712/path-finding" target="_blank" rel="noopener">github</a> as well.</p>
</article></main><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/babylonjs/3.3.0-alpha.12/babylon.js"></script><script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script><script src="https://cdn.jsdelivr.net/npm/babylonjs-gui@3.3.0/babylon.gui.min.js"></script><script src="/scripts/index.js" type="text/javascript"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-121717766-1');ga('send','pageview');</script></body></html>