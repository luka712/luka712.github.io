<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>CRT effect - Shadertoy, Unity | luka712 blog</title><meta name="description" content="This time learn how to create CRT effect for games. Done with shadertoy. Unity example is provided as well."><meta name="generator" content="luka712 blog"><meta name="author" content="Luka Erkapic"><meta name="keywords" content="sjaak van den berg, svdb, bitcoin, crypto, payment, integration, bitcoins, wordpress, betaling, webshop, front end, design, ontwerp, developer"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="stylesheet" type="text/css" href="/styles/style.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="160x160" href="/images/favicon-160x160.png"><link rel="icon" type="image/png" sizes="192x192" href="/images/favicon-192x192.png"><meta name="msapplication-TileColor" content="#121315"><meta name="msapplication-TileImage" content="/images/mstile-144x144.png"></head><body itemscope itemtype="https://schema.org/WebPage" onload="onLoad()"><header itemscope itemtype="https://schema.org/WPHeader"><h1><a href="/" alt="luka712 blog" title="luka712 blog" itemprop="headline" class="header">luka712 blog</a></h1><p itemprop="description"></p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/" alt="Home" title="Home" itemprop="url" class="header">Home</a></li><li itemprop="name"><a href="/About" alt="About" title="About" itemprop="url" class="header">About</a></li></ul></nav><div id="render-space"><canvas id="render-canvas"></canvas></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline">CRT effect - Shadertoy, Unity</h1><span class="post-meta">Published on<time itemprop="datePublished" datetime="2018-07-21T20:23:02.000Z"> Saturday, July 21st 2018 at 22:23</time><br>Last updated on<time itemprop="dateModified" datetime="2018-07-21T20:23:02.000Z"> Tuesday, July 24th 2018 at 11:03</time></span><h5 id="INTRO"><a href="#INTRO" class="headerlink" title="INTRO"></a>INTRO</h5><p>Recently I was working on game prototype and one of the things that I wanted to do was CRT effect. Really like that retro feel that it gives. You can check small gameplay section on <a href="https://www.youtube.com/watch?v=kijKQI-YEVQ" target="_blank" rel="noopener">youtube</a>, or try game here on <a href="https://gamejolt.com/games/shootit9000/355614" target="_blank" rel="noopener">gamejolt page</a>.</p>
<p>Try chaning this value to see how effect works, since we’re going to create that.</p>

<form>
<fieldset>
<legend>CRT </legend>
Bend: <input id="CRTBend" type="range" min="1" max="10" value="4"><br>
Vignette size: <input id="CRTVignetteSize" type="range" min="100" max="300" value="200"><br>
Vignette smoothness: <input id="CRTVignetteSmoothness" style="wdith:20%" type="range" min="0" max="20" value="6"><br>
Vignette rounding: <input id="CRTVignetteRounding" type="range" min="0" max="20" value="8"><br>
Scanline 1 lines: <input id="CRTLines1" type="range" min="0" max="300" value="200"><br>
Scanline 1 speed: <input id="CRTSpeed1" type="range" min="-20" max="20" value="-10"><br>
Scanline 2 lines: <input id="CRTLines2" type="range" min="0" max="300" value="20"><br>
Scanline 2 speed: <input id="CRTSpeed2" type="range" min="-20" max="20" value="-4"><br>
Scanlines amount: <input id="CRTScanlinesAmount" type="range" min="0" max="100" value="5"><br>
Noise size: <input id="CRTNoiseSize" type="range" min="0" max="10" value="7"><br>
Noise amount: <input id="CRTNoiseAmount" type="range" min="0" max="100" value="5"><br>
</fieldset>
</form>
<canvas id="CRTRenderCanvas" style="width:100%;height:75%" onload="loadCRT()"></canvas>
<script>
window.addEventListener("load", function() {
    var crtCanvas = document.getElementById('CRTRenderCanvas');
    var postProcessEffect = null,
        sceneInstrumentation = null;

    window.u_crt_bend = 4;
    window.u_crt_vignette_size = 2;
    window.u_crt_vignette_smoothness = .6;
    window.u_crt_vignette_rounding = 8.;
    window.u_crt_time = 0;
    window.u_crt_lines_1 = 200;
    window.u_crt_speed_1 = -10;
    window.u_crt_lines_2 = 20;
    window.u_crt_speed_2 = -4;
    window.u_crt_lines_amount = 0.05;
    window.u_crt_noise_size = 70.;
    window.u_crt_noise_amount = 0.05;

    var crtEngine = new BABYLON.Engine(crtCanvas, true);

    var crtScene = createScene(crtEngine, crtCanvas);
    crtScene.clearColor = new BABYLON.Color3(0, 0, 0);

    crtEngine.runRenderLoop(function () {
        crtScene.render();
        window.u_crt_time += 0.01;
    });

    window.addEventListener('crtResize', function () {
        setUpCanvas();
        crtEngine.resize();
        crtScene.render();
    });

    document.getElementById("CRTBend").addEventListener("change", function(e){
         window.u_crt_bend = parseFloat(e.currentTarget.value);
    });
    document.getElementById("CRTVignetteSize").addEventListener("change", function(e){
           window.u_crt_vignette_size = parseFloat(e.currentTarget.value) / 100;
    });
    document.getElementById("CRTVignetteSmoothness").addEventListener("change", function(e){
           window.u_crt_vignette_smoothness = parseFloat(e.currentTarget.value) / 10;
    });
    document.getElementById("CRTVignetteRounding").addEventListener("change", function(e){
           window.u_crt_vignette_rounding = parseFloat(e.currentTarget.value);
    });
    document.getElementById("CRTLines1").addEventListener("change", function(e){
           window.u_crt_lines_1 = parseFloat(e.currentTarget.value);
    });
    document.getElementById("CRTLines2").addEventListener("change", function(e){
           window.u_crt_lines_2 = parseFloat(e.currentTarget.value);
    });
    document.getElementById("CRTSpeed1").addEventListener("change", function(e){
           window.u_crt_speed_1 = parseFloat(e.currentTarget.value);
    });
    document.getElementById("CRTSpeed2").addEventListener("change", function(e){
           window.u_crt_speed_2 = parseFloat(e.currentTarget.value);
    });
    document.getElementById("CRTScanlinesAmount").addEventListener("change", function(e){
           window.u_crt_lines_amount = parseFloat(e.currentTarget.value) / 100;
    });
    document.getElementById("CRTNoiseSize").addEventListener("change", function(e){
           window.u_crt_noise_size = parseFloat(e.currentTarget.value) * 10;
    });
    document.getElementById("CRTNoiseAmount").addEventListener("change", function(e){
           window.u_crt_noise_amount = parseFloat(e.currentTarget.value) / 100;
    });


function createScene(engine, canvas) {
    var crtScene = new BABYLON.Scene(engine);

    crtScene.clearColor = BABYLON.Color3.Blue();

    var camera = new BABYLON.FreeCamera('camera', new BABYLON.Vector3(0, 0, -9), crtScene);
   // var light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0,1,0), crtScene);

    camera.setTarget(BABYLON.Vector3.Zero());

    camera.attachControl(canvas, true);

    var plane = BABYLON.MeshBuilder.CreatePlane("plane", { width: 16, height: 9}, crtScene);
    plane.material = new BABYLON.StandardMaterial("planeMaterial", crtScene);
    plane.material.diffuseTexture = new BABYLON.VideoTexture("video", ["/images/6/skate_l.ogv"], crtScene, true);
    plane.material.diffuseTexture.video.play();

    sceneInstrumentation = new BABYLON.SceneInstrumentation(crtScene);
    sceneInstrumentation.captureFrameTime = true;

    var tex = new BABYLON.VideoTexture("video", ["/images/6/skate_l.ogv"], crtScene, true);

    postProcessEffect = postProcess(camera, canvas);
    postProcessEffect.onApply = function (effect) {
         effect.setTexture("u_texture", tex);
         effect.setFloat("u_crt_vignette_rounding", window.u_crt_vignette_rounding);
         effect.setFloat("u_crt_bend", window.u_crt_bend);
         effect.setFloat("u_crt_vignette_size", window.u_crt_vignette_size);
         effect.setFloat("u_crt_vignette_smoothness", window.u_crt_vignette_smoothness);
         effect.setFloat("u_crt_time", window.u_crt_time);
         effect.setFloat("u_crt_lines_1", window.u_crt_lines_1);
         effect.setFloat("u_crt_speed_1", window.u_crt_speed_1);
         effect.setFloat("u_crt_lines_2", window.u_crt_lines_2);
         effect.setFloat("u_crt_speed_2", window.u_crt_speed_2);
         effect.setFloat("u_crt_lines_amount", window.u_crt_lines_amount);
         effect.setFloat("u_crt_noise_amount", window.u_crt_noise_amount);
         effect.setFloat("u_crt_noise_size", window.u_crt_noise_size);
    };

    return crtScene;
}


function postProcess(camera, canvas) {
        BABYLON.Effect.ShadersStore["customFragmentShader"] = `
        #ifdef GL_ES
            precision highp float;
        #endif

        // Samplers
        varying vec2 vUV;
        uniform sampler2D textureSampler;

        // Uniforms
        uniform sampler2D u_texture;
        uniform float u_crt_bend;
        uniform float u_crt_vignette_size;
        uniform float u_crt_vignette_rounding;
        uniform float u_crt_vignette_smoothness;
        uniform float u_crt_time;
        uniform float u_crt_lines_1;
        uniform float u_crt_speed_1;
        uniform float u_crt_lines_2;
        uniform float u_crt_speed_2;
        uniform float u_crt_lines_amount;
        uniform float u_crt_noise_amount;
        uniform float u_crt_noise_size;


        vec2 crt_coords(vec2 uv, float bend)
        {
            uv -= .5;
            uv *= 2.;

            uv.x *= 1. + pow(abs(uv.y) / bend, 2.);
            uv.y *= 1. + pow(abs(uv.x) / bend, 2.);

            uv /= 2.;
            return uv + .5;
        }

        float vignette(vec2 uv, float size, float smoothness, float round)
        {
            uv -= .5;
            uv *= size;
            float amount = sqrt(pow(abs(uv.x), round) + pow(abs(uv.y), round));
            amount = 1. - amount;
            return smoothstep(0., smoothness, amount);
        }

        float scanline(vec2 uv, float lines, float speed)
        {
            return sin(uv.y * lines + u_crt_time * speed);
        }

        float random(vec2 uv)
        {
            return fract(sin(dot(uv, vec2(15.5151, 42.2516))) * 12415.25111 * sin(u_crt_time * 0.03));
        }

        float noise(vec2 uv)
        {
            vec2 i = floor(uv);
            vec2 f = fract(uv);

            float a = random(i);
            float b = random(i + vec2(1.,0.));
            float c = random(i + vec2(0.,1.));
            float d = random(i + vec2(1.));

            vec2 u = smoothstep(0., 1., f);
            return mix(a,b,u.x) + (c-a) * u.y * (1. - u.x) + (d-b) * u.x * u.y;
        }

        void main(void) 
        {
            vec2 uv = vec2(vUV.x, vUV.y * 0.75 + .125);
            vec2 crt_uv = crt_coords(uv, u_crt_bend);
            vec4 col = texture2D(u_texture, crt_uv);

            float s1 = scanline(uv, u_crt_lines_1, u_crt_speed_1);
            float s2 = scanline(uv, u_crt_lines_2, u_crt_speed_2);
            float v = vignette(vUV, u_crt_vignette_size, u_crt_vignette_smoothness, u_crt_vignette_rounding);
            col = vec4(mix(col.xyz, vec3(s1+s2), u_crt_lines_amount), 1.);
            gl_FragColor = vec4(mix(col.xyz, vec3(noise(uv * u_crt_noise_size)), u_crt_noise_amount) * v, 1.);
        }
        `;

    return new BABYLON.PostProcess("My custom post process", "custom", ["u_texture", "u_crt_vignette_smoothness", "u_crt_bend",  "u_crt_vignette_size", "u_crt_vignette_rounding", "u_crt_time", "u_crt_lines_1" , "u_crt_speed_1", "u_crt_lines_2", "u_crt_speed_2", "u_crt_lines_amount", "u_crt_noise_amount", "u_crt_noise_size"], ["u_texture"], 1, camera);
}

});


</script>


<p>To get that, shaders are going to be used, if you’re not familiar with shaders, I already did introduction blog post <a href="2018/07/01/Pixelate-it-Shadertoy-Unity/">here</a>.</p>
<p>Just like in that post, I’m going to do shadertoy example first, and then create Unity example.</p>
<p>If you still haven’t opened shadertoy, <a href="https://www.shadertoy.com/new" target="_blank" rel="noopener">click here</a>.</p>
<p>Now delete middle line and add texture. Your code should look like this</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> mainImage( <span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord/iResolution.xy;</span><br><span class="line">    </span><br><span class="line">    fragColor = <span class="built_in">texture</span>(iChannel0, uv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As always, first we normalize coordinates to be in 0 to 1 space by dividing them with resolution. Next line just creates texture. Make sure that you have selected video or texture for <em>iChannel0</em> just below editor code.</p>
<h5 id="CRT-coords-and-vignette"><a href="#CRT-coords-and-vignette" class="headerlink" title="CRT coords and vignette"></a>CRT coords and vignette</h5><p>One of the first things to do is to add it that rounded feeling of crt screen. This is done by transforming coordinates.</p>
<p>Add this function just above <em>mainImage</em> function.</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> crt_coords(<span class="type">vec2</span> uv, <span class="type">float</span> bend)</span><br><span class="line">&#123;</span><br><span class="line">	uv -= <span class="number">0.5</span>;</span><br><span class="line">    uv *= <span class="number">2.</span>;</span><br><span class="line">    uv.x *= <span class="number">1.</span> + <span class="built_in">pow</span>(<span class="built_in">abs</span>(uv.y)/bend, <span class="number">2.</span>);</span><br><span class="line">    uv.y *= <span class="number">1.</span> + <span class="built_in">pow</span>(<span class="built_in">abs</span>(uv.x)/bend, <span class="number">2.</span>);</span><br><span class="line">    </span><br><span class="line">    uv /= <span class="number">2.</span>;</span><br><span class="line">    <span class="keyword">return</span> uv + <span class="number">.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>then instead of uv coordinate, use our new ones. I will explain code in a moment</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> crt_uv = crt_coords(uv, <span class="number">4.</span>);</span><br><span class="line"></span><br><span class="line">fragColor = <span class="built_in">texture</span>(iChannel0, crt_uv);</span><br></pre></td></tr></table></figure>
<p><em>crt_coords</em> might seem like mistery, but it’s actually quite simple.<br>First two lines<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uv -= <span class="number">0.5</span>;</span><br><span class="line">uv *= <span class="number">2.</span>;</span><br></pre></td></tr></table></figure></p>
<p>just put coordinates from 0 to 1. space into -1. to 1. space.<br>By subtracting 0.5, we go from 0 to 1 into -0.5 to 0.5. Multiplying by puts us in -1 to 1 space.</p>
<p> Now from -1 to 1 space we can easily manipulate coordinates</p>
<p> And lines<br> <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uv.x *= <span class="number">1.</span> + <span class="built_in">pow</span>(<span class="built_in">abs</span>(uv.y)/bend, <span class="number">2.</span>);</span><br><span class="line">uv.y *= <span class="number">1.</span> + <span class="built_in">pow</span>(<span class="built_in">abs</span>(uv.x)/bend, <span class="number">2.</span>);</span><br></pre></td></tr></table></figure></p>
<p> do just that.</p>
<p>Main part of course is <em>pow(abs(uv.y)/bend, 2.)</em> and <em>pow(abs(uv.x)/bend, 2.)</em>.<br>This is function that will curve coordinates and here is excatly how that looks like <a href="https://www.desmos.com/calculator/zxd9hdpnsn" target="_blank" rel="noopener">Desmos</a>.</p>
<p>I usually use tools like that when it comes to functions, since it really helps with modeling.<br>Try playing with values a bit to see how it affects curvature.</p>
<p>Lines<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uv /= <span class="number">2.</span>;</span><br><span class="line"><span class="keyword">return</span> uv + <span class="number">.5</span>;</span><br></pre></td></tr></table></figure></p>
<p>just return coordinates to 0 to 1 space.</p>
<p>Next we need to add vignette, which can be done with distance formula.</p>
<p>So</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vignette(<span class="type">vec2</span> uv)</span><br><span class="line">&#123;</span><br><span class="line"> 	uv -= <span class="number">.5</span>;</span><br><span class="line">    <span class="type">float</span> amount = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(uv.x, <span class="number">2.</span>) + <span class="built_in">pow</span>(uv.y, <span class="number">2.</span>));</span><br><span class="line">    <span class="keyword">return</span> amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>First line simply puts us in -0.5 to 0.5 space by subtracting 0.5 from x and y component of vector. Note, origin here is at (0,0) point.<br>We can imagine second line as distance formula, where we are looking at distance from origin and distance point is (uv.x, uv.y).</p>
<p>For distance formula see <a href="https://www.youtube.com/watch?v=0IOEPcAHgi4" target="_blank" rel="noopener">this</a></p>
<p>What this means is, the further away the points (uv.x, uv.y) is from center, greater the amount of distance is.</p>
<p>Now just multiply texture by vignette.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fragColor = texture(iChannel0, crt_uv) * vignette(uv);</span><br></pre></td></tr></table></figure>
<p>All code so far:</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> crt_coords(<span class="type">vec2</span> uv, <span class="type">float</span> bend)</span><br><span class="line">&#123;</span><br><span class="line">	uv -= <span class="number">0.5</span>;</span><br><span class="line">    uv *= <span class="number">2.</span>;</span><br><span class="line">    uv.x *= <span class="number">1.</span> + <span class="built_in">pow</span>(<span class="built_in">abs</span>(uv.y)/bend, <span class="number">2.</span>);</span><br><span class="line">    uv.y *= <span class="number">1.</span> + <span class="built_in">pow</span>(<span class="built_in">abs</span>(uv.x)/bend, <span class="number">2.</span>);</span><br><span class="line">    </span><br><span class="line">    uv /= <span class="number">2.5</span>;</span><br><span class="line">    <span class="keyword">return</span> uv + <span class="number">.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> vignette(<span class="type">vec2</span> uv)li</span><br><span class="line">&#123;</span><br><span class="line"> 	uv -= <span class="number">.5</span>;</span><br><span class="line">    <span class="type">float</span> amount = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(uv.x, <span class="number">2.</span>) + <span class="built_in">pow</span>(uv.y, <span class="number">2.</span>));</span><br><span class="line">    <span class="keyword">return</span> amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage( <span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord/iResolution.xy;</span><br><span class="line">    </span><br><span class="line">    <span class="type">vec2</span> crt_uv = crt_coords(uv, <span class="number">4.</span>);</span><br><span class="line">    </span><br><span class="line">    fragColor = <span class="built_in">texture</span>(iChannel0, crt_uv) * vignette(uv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And final image should be something like this, of course depending on your texture/video in iChannel0 image might be different.</p>
<p><img src="/images/6/image1.png" style="width:50%"></p>
<p>Well that’s not right and that’s because distance amount near origin is 0, which results in small values when multiplying, that why there is black color. You might notice that we only need to reverse the effect.<br>So in vignette function add line<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float amount = sqrt(pow(uv.x, 2.) + pow(uv.y, 2.));</span><br><span class="line">amount = 1. - amount;</span><br><span class="line">return amount;</span><br></pre></td></tr></table></figure></p>
<p>It should look bit more like what we want to get.</p>
<p><img src="/images/6/image2.png" style="width:50%"></p>
<p>We can still improve on it though. Change code for vignette to this.</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vignette(<span class="type">vec2</span> uv, <span class="type">float</span> size, <span class="type">float</span> smoothness, <span class="type">float</span> edgeRounding)</span><br><span class="line">&#123;</span><br><span class="line"> 	uv -= <span class="number">.5</span>;</span><br><span class="line">    uv *= size;</span><br><span class="line">    <span class="type">float</span> amount = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(<span class="built_in">abs</span>(uv.x), edgeRounding) + <span class="built_in">pow</span>(<span class="built_in">abs</span>(uv.y), edgeRounding));</span><br><span class="line">    amount = <span class="number">1.</span> - amount;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smoothstep</span>(<span class="number">0.</span>, smoothness, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>uv *= size</em> gives you control, well over vignette size, bigger size is, closer to center vignette is.<br><em>float amount = sqrt(abs(pow(uv.x, edgeRounding)) + abs(pow(uv.y, edgeRounding)));</em> and <em>edgeRounding</em> will improve edges a bit. Please note that I have used <em>abs</em> function here, since odd number exponent of negative number gives negative value, therefore use absolute value.<br>Finally <em>return smoothstep(0., smoothness, amount);</em>  will give you control over amount of <em>blackness</em> of vignette. There is really nice explenation of <em>smoothstep</em> <a href="https://thebookofshaders.com/glossary/?search=smoothstep" target="_blank" rel="noopener">here</a>. I’m goint to refrence <em>Book of shaders</em> couple of times during this post, it’s really great read.</p>
<p>Finally pass paramteres to vignette function.<br>This worked really nice for me.</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fragColor = <span class="built_in">texture</span>(iChannel0, crt_uv) * vignette(uv, <span class="number">1.9</span>, <span class="number">.6</span>, <span class="number">8.</span>);</span><br></pre></td></tr></table></figure>
<p>Now it looks like this.</p>
<p><img src="/images/6/image3.png" style="width:50%"></p>
<p>Code so far: </p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> crt_coords(<span class="type">vec2</span> uv, <span class="type">float</span> bend)</span><br><span class="line">&#123;</span><br><span class="line">	uv -= <span class="number">0.5</span>;</span><br><span class="line">    uv *= <span class="number">2.</span>;</span><br><span class="line">    uv.x *= <span class="number">1.</span> + <span class="built_in">pow</span>(<span class="built_in">abs</span>(uv.y)/bend, <span class="number">2.</span>);</span><br><span class="line">    uv.y *= <span class="number">1.</span> + <span class="built_in">pow</span>(<span class="built_in">abs</span>(uv.x)/bend, <span class="number">2.</span>);</span><br><span class="line">    </span><br><span class="line">    uv /= <span class="number">2.5</span>;</span><br><span class="line">    <span class="keyword">return</span> uv + <span class="number">.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> vignette(<span class="type">vec2</span> uv, <span class="type">float</span> size, <span class="type">float</span> smoothness, <span class="type">float</span> edgeRounding)</span><br><span class="line">&#123;</span><br><span class="line"> 	uv -= <span class="number">.5</span>;</span><br><span class="line">    uv *= size;</span><br><span class="line">    <span class="type">float</span> amount = <span class="built_in">sqrt</span>(<span class="built_in">abs</span>(<span class="built_in">pow</span>(uv.x, edgeRounding)) + <span class="built_in">abs</span>(<span class="built_in">pow</span>(uv.y, edgeRounding)));</span><br><span class="line">    amount = <span class="number">1.</span> - amount;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smoothstep</span>(<span class="number">0.</span>, smoothness, amount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage( <span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord/iResolution.xy;</span><br><span class="line">    </span><br><span class="line">    <span class="type">vec2</span> crt_uv = crt_coords(uv, <span class="number">4.</span>);</span><br><span class="line">    </span><br><span class="line">    fragColor = <span class="built_in">texture</span>(iChannel0, crt_uv) * vignette(uv, <span class="number">1.9</span>, <span class="number">.6</span>, <span class="number">8.</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Scanlines"><a href="#Scanlines" class="headerlink" title="Scanlines"></a>Scanlines</h5><p><em>What is CRT without scanlines?</em></p>
<p>We can easily create scanlines with <em>sin</em> or <em>cos</em> functions. As you already know those functions go from -1 to 1, which is perfect and we’re going to see why in a minute. If you do not know them out of your head, try using <a href="https://www.desmos.com/calculator/lysndl1qpt" target="_blank" rel="noopener">Desmos</a> again to model function, as I said it really helps.</p>
<p>For start add this function<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> scanline(<span class="type">vec2</span> uv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sin</span>(uv.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>and behind <em>fragColor</em> add another <em>fragColor</em> like so<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fragColor = <span class="built_in">texture</span>(iChannel0, crt_uv) * vignette(uv, <span class="number">1.9</span>, <span class="number">.6</span>, <span class="number">8.</span>);</span><br><span class="line">fragColor = <span class="type">vec4</span>(scanline(uv));</span><br></pre></td></tr></table></figure></p>
<p>We’re going to use second one just for <em>debugging</em> ( there is no debug mode in shadertoy as far as I know, but we have to visualize data somehow).</p>
<p>Try to run it.</p>
<p><img src="/images/6/image4.png" style="width:50%"></p>
<p>Doesn’t look like much.</p>
<p>But try this</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> scanline(<span class="type">vec2</span> uv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sin</span>(uv.y * <span class="number">200.</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And now we have something that will represent lines better.</p>
<p><img src="/images/6/image5.png" style="width:50%"></p>
<p>Refactor it so that we that <em>200.</em> as parameter. I will call it simply <em>lines</em>. It’s not lines excatly, but probably better then <em>rateOfChange</em>. While we’re at it, let’s add time to it, so that we can move lines.</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> scanline(<span class="type">vec2</span> uv, <span class="type">float</span> <span class="keyword">lines</span>, <span class="type">float</span> speed)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sin</span>(uv.y * <span class="keyword">lines</span> + iTime * speed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Perfect, now with <em>lines</em> parameter we can control amount of lines, while <em>speed</em> controls direction and magnitude of lines movement.</p>
<p>Now we just need to combine it with original image, which can be done with <em>mix</em> function.</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> s1 = scanline(uv, <span class="number">200.</span>, <span class="number">-10.</span>);</span><br><span class="line">fragColor = <span class="built_in">mix</span>(<span class="built_in">texture</span>(iChannel0, crt_uv), <span class="type">vec4</span>(s1), <span class="number">0.05</span>) * vignette(uv, <span class="number">1.9</span>, <span class="number">.6</span>, <span class="number">8.</span>);</span><br></pre></td></tr></table></figure>
<p><em>Mix</em> function is just built in function for <a href="https://thebookofshaders.com/glossary/?search=mix" target="_blank" rel="noopener">linear interpolation</a>. It just says how much of something we want between two values.</p>
<p>Try to run now and you should have lines moving and pretty good crt effect.<br>Handy thing is, we can create more lines for better effect. Then just add them.<br>Your code should look something like this now, with multiple scanlines created.</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> crt_coords(<span class="type">vec2</span> uv, <span class="type">float</span> bend)</span><br><span class="line">&#123;</span><br><span class="line">	uv -= <span class="number">0.5</span>;</span><br><span class="line">    uv *= <span class="number">2.</span>;</span><br><span class="line">    uv.x *= <span class="number">1.</span> + <span class="built_in">pow</span>(<span class="built_in">abs</span>(uv.y)/bend, <span class="number">2.</span>);</span><br><span class="line">    uv.y *= <span class="number">1.</span> + <span class="built_in">pow</span>(<span class="built_in">abs</span>(uv.x)/bend, <span class="number">2.</span>);</span><br><span class="line">    </span><br><span class="line">    uv /= <span class="number">2.5</span>;</span><br><span class="line">    <span class="keyword">return</span> uv + <span class="number">.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> vignette(<span class="type">vec2</span> uv, <span class="type">float</span> size, <span class="type">float</span> smoothness, <span class="type">float</span> edgeRounding)</span><br><span class="line">&#123;</span><br><span class="line"> 	uv -= <span class="number">.5</span>;</span><br><span class="line">    uv *= size;</span><br><span class="line">    <span class="type">float</span> amount = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(<span class="built_in">abs</span>(uv.x), edgeRounding) + <span class="built_in">pow</span>(<span class="built_in">abs</span>(uv.y), edgeRounding));</span><br><span class="line">    amount = <span class="number">1.</span> - amount;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smoothstep</span>(<span class="number">0.</span>, smoothness, amount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> scanline(<span class="type">vec2</span> uv, <span class="type">float</span> <span class="keyword">lines</span>, <span class="type">float</span> speed)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sin</span>(uv.y * <span class="keyword">lines</span> + iTime * speed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage( <span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord/iResolution.xy;</span><br><span class="line">    </span><br><span class="line">    <span class="type">vec2</span> crt_uv = crt_coords(uv, <span class="number">4.</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> s1 = scanline(uv, <span class="number">200.</span>, <span class="number">-10.</span>);</span><br><span class="line">    <span class="type">float</span> s2 = scanline(uv, <span class="number">20.</span>, <span class="number">-3.</span>);</span><br><span class="line">    fragColor = <span class="built_in">mix</span>(<span class="built_in">texture</span>(iChannel0, crt_uv), <span class="type">vec4</span>(s1 + s2), <span class="number">0.05</span>) * vignette(uv, <span class="number">1.9</span>, <span class="number">.6</span>, <span class="number">8.</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/6/image6.png" style="width:50%"></p>
<h5 id="Noise"><a href="#Noise" class="headerlink" title="Noise"></a>Noise</h5><p>For noise we can use <a href="https://en.wikipedia.org/wiki/Perlin_noise" target="_blank" rel="noopener">Perlin noise</a>. Now how does that look like.<br>Well think of it as randomness with nice smooth transitions between values.</p>
<p>But first we do need randomness. Sadly there is no random function with shaders like there is when programming on CPU side of things. There is however way to create good enough <em>random</em> function. Instead of going through it, I’m going to reference <a href="https://thebookofshaders.com/10/" target="_blank" rel="noopener">this free book</a> since it perfectly explains <em>random</em> values.</p>
<p>Going from that we can add random function.</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> random(<span class="type">vec2</span> uv)</span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="built_in">fract</span>(<span class="built_in">sin</span>(<span class="built_in">dot</span>(uv, <span class="type">vec2</span>(<span class="number">15.5151</span>, <span class="number">42.2561</span>))) * <span class="number">12341.14122</span> * <span class="built_in">sin</span>(iTime * <span class="number">0.03</span>));   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you try to visualize it, you can notice that there is a bit of repeating pattern, but it should be good enough.</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fragColor = <span class="type">vec4</span>(random(uv));</span><br></pre></td></tr></table></figure>
<p><img src="/images/6/image7.png" style="width:50%"></p>
<p>For Perlin noise, we’re also going to shamelessly use code from <a href="https://thebookofshaders.com/11/" target="_blank" rel="noopener">Book of Shaders</a> as it is explained there in detail.</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> noise(<span class="type">vec2</span> uv)</span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="type">vec2</span> i = <span class="built_in">floor</span>(uv);</span><br><span class="line">    <span class="type">vec2</span> f = <span class="built_in">fract</span>(uv);</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> a = random(i);</span><br><span class="line">    <span class="type">float</span> b = random(i + <span class="type">vec2</span>(<span class="number">1.</span>,<span class="number">0.</span>));</span><br><span class="line">	<span class="type">float</span> c = random(i + <span class="type">vec2</span>(<span class="number">0.</span>, <span class="number">1.</span>));</span><br><span class="line">    <span class="type">float</span> d = random(i + <span class="type">vec2</span>(<span class="number">1.</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="type">vec2</span> u = <span class="built_in">smoothstep</span>(<span class="number">0.</span>, <span class="number">1.</span>, f);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mix</span>(a,b, u.x) + (c - a) * u.y * (<span class="number">1.</span> - u.x) + (d - b) * u.x * u.y; </span><br><span class="line">                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And finally check noise function</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fragColor = <span class="type">vec4</span>(noise(uv * <span class="number">75.</span>));</span><br></pre></td></tr></table></figure>
<p><img src="/images/6/image8.png" style="width:50%"></p>
<p>We just need to mix noise with image now.</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> col = <span class="built_in">mix</span>(<span class="built_in">texture</span>(iChannel0, crt_uv), <span class="type">vec4</span>(s1 + s2), <span class="number">0.05</span>) * vignette(uv, <span class="number">1.9</span>, <span class="number">.6</span>, <span class="number">8.</span>);</span><br><span class="line">fragColor = <span class="built_in">mix</span>(col, <span class="type">vec4</span>(noise(uv * <span class="number">75.</span>)), <span class="number">0.05</span>);</span><br></pre></td></tr></table></figure>
<p>And </p>
<p><img src="/images/6/image9.png" style="width:50%"></p>
<p>there it is. It’s really nice CRT effect. You can improve it further by adding maybe <a href="/2018/07/14/Chromatic-Abberation-Shadertoy-Unity/">chromatic aberration</a> effect.</p>
<p>Here is my final shadertoy <a href="https://www.shadertoy.com/view/Xtccz4" target="_blank" rel="noopener">example</a>.</p>
<h5 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h5><p>This not hard to do in Unity. There are just 2 things needed, C# script on camera for post processing and shader of course. If you find this part of post bit confusing, try checking out <a href="2018/07/01/Pixelate-it-Shadertoy-Unity/">pixelate it post</a> where I have explained setting up post process bit more in details.</p>
<p>Let’s start with shader</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">Shader "Hidden/CrtPostProcess"</span><br><span class="line">&#123;</span><br><span class="line">	Properties</span><br><span class="line">	&#123;</span><br><span class="line">		_MainTex ("Texture", 2D) = "white" &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// No culling or depth</span></span><br><span class="line">		Cull Off ZWrite Off ZTest Always</span><br><span class="line"></span><br><span class="line">		Pass</span><br><span class="line">		&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include "UnityCG.cginc"</span></span><br><span class="line"></span><br><span class="line">			struct appdata</span><br><span class="line">			&#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			struct v2f</span><br><span class="line">			&#123;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">				float4 vertex : SV_POSITION;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			v2f vert (appdata v)</span><br><span class="line">			&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.uv = v.uv;</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line">			<span class="keyword">uniform</span> <span class="type">float</span> u_bend;</span><br><span class="line">			<span class="keyword">uniform</span> <span class="type">float</span> u_scanline_size_1;</span><br><span class="line">			<span class="keyword">uniform</span> <span class="type">float</span> u_scanline_speed_1;</span><br><span class="line">			<span class="keyword">uniform</span> <span class="type">float</span> u_scanline_size_2;</span><br><span class="line">			<span class="keyword">uniform</span> <span class="type">float</span> u_scanline_speed_2;</span><br><span class="line">			<span class="keyword">uniform</span> <span class="type">float</span> u_scanline_amount;</span><br><span class="line">			<span class="keyword">uniform</span> <span class="type">float</span> u_vignette_size;</span><br><span class="line">			<span class="keyword">uniform</span> <span class="type">float</span> u_vignette_smoothness;</span><br><span class="line">			<span class="keyword">uniform</span> <span class="type">float</span> u_vignette_edge_round;</span><br><span class="line">			<span class="keyword">uniform</span> <span class="type">float</span> u_noise_size;</span><br><span class="line">			<span class="keyword">uniform</span> <span class="type">float</span> u_noise_amount;</span><br><span class="line">			<span class="keyword">uniform</span> half2 u_red_offset;</span><br><span class="line">			<span class="keyword">uniform</span> half2 u_green_offset;</span><br><span class="line">			<span class="keyword">uniform</span> half2 u_blue_offset;</span><br><span class="line"></span><br><span class="line">			half2 crt_coords(half2 uv, <span class="type">float</span> bend)</span><br><span class="line">			&#123;</span><br><span class="line">				uv -= <span class="number">0.5</span>;</span><br><span class="line">				uv *= <span class="number">2.</span>;</span><br><span class="line">				uv.x *= <span class="number">1.</span> + <span class="built_in">pow</span>(<span class="built_in">abs</span>(uv.y) / bend, <span class="number">2.</span>);</span><br><span class="line">				uv.y *= <span class="number">1.</span> + <span class="built_in">pow</span>(<span class="built_in">abs</span>(uv.x) / bend, <span class="number">2.</span>);</span><br><span class="line"></span><br><span class="line">				uv /= <span class="number">2.5</span>;</span><br><span class="line">				<span class="keyword">return</span> uv + <span class="number">0.5</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="type">float</span> vignette(half2 uv, <span class="type">float</span> size, <span class="type">float</span> smoothness, <span class="type">float</span> edgeRounding)</span><br><span class="line">			&#123;</span><br><span class="line">				uv -= <span class="number">.5</span>;</span><br><span class="line">				uv *= size;</span><br><span class="line">				<span class="type">float</span> amount = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(<span class="built_in">abs</span>(uv.x), edgeRounding) + <span class="built_in">pow</span>(<span class="built_in">abs</span>(uv.y), edgeRounding));</span><br><span class="line">				amount = <span class="number">1.</span> - amount;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">smoothstep</span>(<span class="number">0</span>, smoothness, amount);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="type">float</span> scanline(half2 uv, <span class="type">float</span> <span class="keyword">lines</span>, <span class="type">float</span> speed)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">sin</span>(uv.y * <span class="keyword">lines</span> + u_time * speed);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="type">float</span> random(half2 uv)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> frac(<span class="built_in">sin</span>(<span class="built_in">dot</span>(uv, half2(<span class="number">15.1511</span>, <span class="number">42.5225</span>))) * <span class="number">12341.51611</span> * <span class="built_in">sin</span>(u_time * <span class="number">0.03</span>));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="type">float</span> noise(half2 uv)</span><br><span class="line">			&#123;</span><br><span class="line">				half2 i = <span class="built_in">floor</span>(uv);</span><br><span class="line">				half2 f = frac(uv);</span><br><span class="line"></span><br><span class="line">				<span class="type">float</span> a = random(i);</span><br><span class="line">				<span class="type">float</span> b = random(i + half2(<span class="number">1.</span>, <span class="number">0.</span>));</span><br><span class="line">				<span class="type">float</span> c = random(i + half2(<span class="number">0</span>, <span class="number">1.</span>));</span><br><span class="line">				<span class="type">float</span> d = random(i + half2(<span class="number">1.</span>, <span class="number">1.</span>));</span><br><span class="line"></span><br><span class="line">				half2 u = <span class="built_in">smoothstep</span>(<span class="number">0.</span>, <span class="number">1.</span>, f);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> lerp(a, b, u.x) + (c - a) * u.y * (<span class="number">1.</span> - u.x) + (d - b) * u.x * u.y;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			fixed4 frag (v2f i) : SV_Target</span><br><span class="line">			&#123;</span><br><span class="line">				half2 crt_uv = crt_coords(i.uv, u_bend);</span><br><span class="line">				fixed4 col;</span><br><span class="line">				col.r = tex2D(_MainTex, crt_uv + u_red_offset).r;</span><br><span class="line">				col.g = tex2D(_MainTex, crt_uv + u_green_offset).g;</span><br><span class="line">				col.b = tex2D(_MainTex, crt_uv + u_blue_offset).b;</span><br><span class="line">				col.a = tex2D(_MainTex, crt_uv).a;</span><br><span class="line"></span><br><span class="line">				<span class="type">float</span> s1 = scanline(i.uv, u_scanline_size_1, u_scanline_speed_1);</span><br><span class="line">				<span class="type">float</span> s2 = scanline(i.uv, u_scanline_size_2, u_scanline_speed_2);</span><br><span class="line"></span><br><span class="line">				col = lerp(col, fixed(s1 + s2), u_scanline_amount);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> lerp(col, fixed(noise(i.uv * u_noise_size)), u_noise_amount) * vignette(i.uv, u_vignette_size, u_vignette_smoothness, u_vignette_edge_round);</span><br><span class="line">			&#125;</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It’s is almost the same code as <em>shadertoy</em> example, so it should be pretty clear by now. Notice that <em>mix</em> is called <em>lerp</em> in Unity shader. </p>
<p>Part with bunch of uniforms </p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_bend;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_scanline_size_1;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_scanline_speed_1;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_scanline_size_2;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_scanline_speed_2;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_scanline_amount;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_vignette_size;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_vignette_smoothness;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_vignette_edge_round;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_noise_size;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_noise_amount;</span><br><span class="line"><span class="keyword">uniform</span> half2 u_red_offset;</span><br><span class="line"><span class="keyword">uniform</span> half2 u_green_offset;</span><br><span class="line"><span class="keyword">uniform</span> half2 u_blue_offset;</span><br></pre></td></tr></table></figure>
<p>allows us to access shader content from CPU, that is we can access this variables from C# script.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CRTPostProcess</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Shader shader;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> bend = <span class="number">4</span>f;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> scanlineSize1 = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> scanlineSpeed1 = <span class="number">-10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> scanlineSize2 = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> scanlineSpeed2 = <span class="number">-3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> scanlineAmount = <span class="number">0.05</span>f;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> vignetteSize = <span class="number">1.9</span>f;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> vignetteSmoothness = <span class="number">0.6</span>f;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> vignetteEdgeRound = <span class="number">8</span>f;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> noiseSize = <span class="number">75</span>f;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> noiseAmount = <span class="number">0.05</span>f;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Chromatic aberration amounts</span></span><br><span class="line">    <span class="keyword">public</span> Vector2 redOffset = <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">-0.01</span>f);</span><br><span class="line">    <span class="keyword">public</span> Vector2 blueOffset = Vector2.zero;</span><br><span class="line">    <span class="keyword">public</span> Vector2 greenOffset = <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">0.01</span>f);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Material material;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use this for initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        material = <span class="keyword">new</span> Material(shader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        material.SetFloat(<span class="string">"u_time"</span>, Time.fixedTime);</span><br><span class="line">        material.SetFloat(<span class="string">"u_bend"</span>, bend);</span><br><span class="line">        material.SetFloat(<span class="string">"u_scanline_size_1"</span>, scanlineSize1);</span><br><span class="line">        material.SetFloat(<span class="string">"u_scanline_speed_1"</span>, scanlineSpeed1);</span><br><span class="line">        material.SetFloat(<span class="string">"u_scanline_size_2"</span>, scanlineSize2);</span><br><span class="line">        material.SetFloat(<span class="string">"u_scanline_speed_2"</span>, scanlineSpeed2);</span><br><span class="line">        material.SetFloat(<span class="string">"u_scanline_amount"</span>, scanlineAmount);</span><br><span class="line">        material.SetFloat(<span class="string">"u_vignette_size"</span>, vignetteSize);</span><br><span class="line">        material.SetFloat(<span class="string">"u_vignette_smoothness"</span>, vignetteSmoothness);</span><br><span class="line">        material.SetFloat(<span class="string">"u_vignette_edge_round"</span>, vignetteEdgeRound);</span><br><span class="line">        material.SetFloat(<span class="string">"u_noise_size"</span>, noiseSize);</span><br><span class="line">        material.SetFloat(<span class="string">"u_noise_amount"</span>, noiseAmount);</span><br><span class="line">        material.SetVector(<span class="string">"u_red_offset"</span>, redOffset);</span><br><span class="line">        material.SetVector(<span class="string">"u_blue_offset"</span>, blueOffset);</span><br><span class="line">        material.SetVector(<span class="string">"u_green_offset"</span>, greenOffset);</span><br><span class="line">        Graphics.Blit(source, destination, material);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And that’s it.</p>
<p>As always code examples are on <a href="https://github.com/luka712/Unity-Effects/tree/master/CRT" target="_blank" rel="noopener">github</a> and my implementation of shader on <a href="https://www.shadertoy.com/view/Xtccz4" target="_blank" rel="noopener">shadertoy page</a>.</p>
</article></main><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/babylonjs/3.3.0-alpha.12/babylon.js"></script><script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script><script src="https://preview.babylonjs.com/gui/babylon.gui.js"></script><script src="/scripts/index.js" type="text/javascript"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-121717766-1');ga('send','pageview');</script></body></html>